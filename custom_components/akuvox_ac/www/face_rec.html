<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox Face Enrolment</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
  <style>
    :root{ --bg:#0b1320; --card:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc; }
    body{ background:var(--bg); color:var(--text); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .card{ background:#111a2b; border:1px solid #1b2942; }
    .muted{ color:var(--muted); }
    .btn-row{ gap:.5rem; flex-wrap:wrap; }
  </style>
</head>
<body>
<script>
/* ---------- Auth + helpers ---------- */
(function () {
  const qs = new URLSearchParams(location.search);
  const qsToken = qs.get('token');
  if (qsToken) sessionStorage.setItem('akuvox_ll_token', qsToken);
})();
function findHaToken(){ const t = sessionStorage.getItem('akuvox_ll_token'); return t || null; }
const SAME_ORIGIN = { credentials: 'same-origin' };
const REJECTED_TOKENS = new Set();

const AUTH_SIG_KEY = 'akuvox_auth_sig';

function readAuthSigFrom(search = location.search){
  try {
    const params = new URLSearchParams(search);
    const value = params.get('authSig');
    return value || '';
  } catch (err) {
    return '';
  }
}

function rememberAuthSig(value){
  if (!value) return;
  try { sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { window.AK_AC_AUTH_SIG = value; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      const parent = window.parent;
      try { parent.sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.AK_AC_AUTH_SIG = value; } catch (err) {}
    }
  } catch (err) {}
}

function currentAuthSig(){
  const fromUrl = readAuthSigFrom();
  if (fromUrl) {
    rememberAuthSig(fromUrl);
    return fromUrl;
  }

  const sources = [
    () => {
      try { return sessionStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return localStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return window.AK_AC_AUTH_SIG || null; } catch (err) { return null; }
    },
    () => {
      try {
        if (window.parent && window.parent !== window) {
          const parent = window.parent;
          return parent.AK_AC_AUTH_SIG
            || (parent.sessionStorage && parent.sessionStorage.getItem(AUTH_SIG_KEY))
            || (parent.localStorage && parent.localStorage.getItem(AUTH_SIG_KEY));
        }
      } catch (err) {}
      return null;
    }
  ];

  for (const getter of sources) {
    const value = getter();
    if (value) {
      rememberAuthSig(value);
      return value;
    }
  }

  return '';
}

rememberAuthSig(readAuthSigFrom());

function nextBearerToken(){
  const token = findHaToken();
  if (!token) return null;
  if (REJECTED_TOKENS.has(token)) return null;
  return token;
}

async function fetchWithAuth(url, options = {}, { allowRetry = true } = {}){
  const originalHeaders = { ...(options.headers || {}) };
  let bearer = allowRetry ? nextBearerToken() : null;
  let usedBearer = !!bearer;
  const headers = { ...originalHeaders };
  if (bearer) headers['Authorization'] = 'Bearer ' + bearer;

  const response = await fetch(url, { ...SAME_ORIGIN, ...options, headers });

  if (allowRetry && usedBearer && (response.status === 401 || response.status === 403)){
    REJECTED_TOKENS.add(bearer);
    const retryToken = nextBearerToken();
    if (retryToken && retryToken !== bearer){
      return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: true });
    }
    return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: false });
  }

  return response;
}

function buildError(res, text){
  const message = `${res.status}: ${text || res.statusText || 'Request failed'}`;
  const err = new Error(message);
  err.status = res.status;
  err.body = text;
  return err;
}

function isAuthError(err){
  if (!err) return false;
  if (err.status === 401 || err.status === 403) return true;
  const msg = String(err.message || err || '').toLowerCase();
  return msg.includes('401') || msg.includes('403') || msg.includes('unauthor');
}

function redirectToUnauthorized(){
  try {
    const path = (window.location.pathname || '').toLowerCase();
    if (path.endsWith('/unauthorized') || path.endsWith('/unauthorized.html')) {
      return true;
    }
  } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'akuvox-nav', view: 'unauthorized', slug: 'unauthorized', params: {} }, window.location.origin);
    }
  } catch (err) {}

  let href = '/akuvox-ac/unauthorized';
  try {
    const search = new URLSearchParams();
    const authSig = currentAuthSig();
    if (authSig) search.set('authSig', authSig);
    const query = search.toString();
    if (query) href = `/akuvox-ac/unauthorized?${query}`;
  } catch (err) {}

  try { window.location.replace(href); }
  catch (err) { window.location.href = href; }
  return true;
}

function handleAuthError(err){
  if (!isAuthError(err)) return false;
  redirectToUnauthorized();
  return true;
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_UPLOAD_FACE = signedPath('upload_face', '/api/akuvox_ac/ui/upload_face');

function qsGet(k){ return new URLSearchParams(location.search).get(k) || ''; }
function normalizeHaId(value){
  if (!value) return '';
  const match = String(value).trim().match(/^HA-?(\d{3,})$/i);
  if (!match) return '';
  return `HA${match[1]}`;
}
const RAW_USER_ID = qsGet('user');      // e.g. HA001 or HA-001
const USER_ID = normalizeHaId(RAW_USER_ID);
const USER_ID_DISPLAY = USER_ID || (RAW_USER_ID ? RAW_USER_ID.trim() : '');
const USER_NAME = (qsGet('name') || '').trim();
const DEVICE_ID = qsGet('device');  // informational for now

let BUSY = false;
function setBusy(yes){
  BUSY = !!yes;
  const busyEl = document.getElementById('busy');
  if (busyEl) busyEl.style.display = yes ? 'inline-block' : 'none';
  document.querySelectorAll('[data-busy-lock]').forEach(el => {
    if (yes){
      if (!el.dataset.busyPrevDisabled){
        el.dataset.busyPrevDisabled = el.disabled ? '1' : '0';
      }
      if ('disabled' in el) el.disabled = true;
    }else if (el.dataset.busyPrevDisabled){
      if ('disabled' in el) el.disabled = el.dataset.busyPrevDisabled === '1';
      delete el.dataset.busyPrevDisabled;
    }
  });
}
function setStatus(msg, good=false){
  const el = document.getElementById('status');
  el.textContent = msg || '';
  el.className = good ? 'text-success' : 'text-warning';
}

/* ---------- Upload helpers ---------- */
async function uploadBlobAsJpg(blob){
  if (BUSY) return;
  if (!USER_ID){
    setStatus('Missing or invalid user id. This page must be opened with ?user=HAXXX (e.g. HA123 or HA-123).', false);
    return;
  }
  const fd = new FormData();
  fd.append('id', USER_ID);
  fd.append('file', blob, USER_ID + '.jpg');

  setBusy(true);
  try{
    const r = await fetchWithAuth(API_UPLOAD_FACE, {
      method:'POST',
      body: fd
    });
    const text = await r.text();
    let res = {};
    try { res = JSON.parse(text); } catch { res = { ok: r.ok, raw: text }; }
    if (!r.ok || res.ok === false){
      const err = res && res.error ? new Error(res.error) : buildError(r, text);
      handleAuthError(err);
      if (res && res.error) err.message = res.error;
      setStatus('Upload failed: ' + (res.error || text || err.message || r.status), false);
      return;
    }
    setStatus('Face uploaded for ' + USER_ID + '. It is now stored in the FaceData folder of Home Assistant and will sync to the device shortly.', true);
  }catch(e){
    if (handleAuthError(e)) return;
    setStatus('Upload error: ' + (e && e.message ? e.message : e), false);
  }finally{
    setBusy(false);
  }
}

async function uploadFromFile(){
  if (BUSY) return;
  const inp = document.getElementById('file');
  if (!inp.files || !inp.files[0]){
    setStatus('Choose a JPG file first.', false);
    return;
  }
  const f = inp.files[0];
  if (!/jpe?g$/i.test(f.name) && f.type !== 'image/jpeg'){
    setStatus('Please select a JPG file.', false);
    return;
  }
  await uploadBlobAsJpg(f);
}

/* ---------- init ---------- */
document.addEventListener('DOMContentLoaded', ()=>{
  const badge = document.getElementById('userBadge');
  const badgeInline = document.getElementById('userBadgeInline');
  if (badge){
    if (USER_ID_DISPLAY){
      badge.textContent = USER_ID_DISPLAY;
    }else{
      badge.textContent = '(unknown)';
    }
    if (!USER_ID){
      badge.style.display = 'none';
    }
  }
  if (badgeInline){
    badgeInline.textContent = USER_ID_DISPLAY || '(unknown)';
    if (!USER_ID) badgeInline.closest('code')?.classList.add('text-warning');
  }
  const nameEl = document.getElementById('userName');
  if (nameEl){
    if (USER_NAME){
      nameEl.textContent = USER_NAME;
    }else{
      nameEl.style.display = 'none';
    }
  }
  setStatus('');
});
</script>

<div class="container py-3">
  <div class="d-flex align-items-center gap-2 mb-2">
    <h3 class="m-0">Face Enrolment</h3>
    <span id="busy" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display:none;"></span>
  </div>

  <div class="card p-3">
    <div class="mb-2 d-flex align-items-center flex-wrap gap-2">
      <span class="muted">User:</span>
      <span id="userName" class="fw-semibold"></span>
      <span id="userBadge" class="badge bg-secondary"></span>
    </div>

    <div class="mb-2 muted">Upload a JPG face photo (stored as <code><span id="userBadgeInline" class="badge bg-secondary"></span>.jpg</code> in Home Assistant):</div>
    <div class="d-flex btn-row align-items-center">
      <input id="file" type="file" accept=".jpg,image/jpeg" capture="environment" class="form-control" style="max-width:420px;" data-busy-lock />
      <button id="uploadFileBtn" class="btn btn-success" onclick="uploadFromFile()" data-busy-lock>Upload selected file</button>
    </div>
  </div>

  <div class="mt-3" id="status"></div>
</div>
</body>
</html>
