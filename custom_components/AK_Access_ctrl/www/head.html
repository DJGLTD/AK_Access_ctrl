<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox Access Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"/>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" crossorigin="anonymous"/>
  <style>
    :root {
      --bg:#0b1320; --panel:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc;
      --accent:#0dcaf0; --accent-dark:#0a92ad;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    .head-wrap {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header.app-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem 0.75rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 1rem;
      z-index: 2;
    }
    header.app-header .brand {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    header.app-header h1 {
      font-size: 1.5rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    header.app-header h1 .bi {
      font-size: 1.3em;
      color: var(--accent);
    }
    header.app-header .version-badge {
      align-self: flex-start;
      font-size: 0.85rem;
      background: rgba(13,202,240,.15);
      color: var(--accent);
      border: 1px solid rgba(13,202,240,.35);
      border-radius: 999px;
      padding: 0.2rem 0.75rem;
    }
    nav.nav-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    nav.nav-buttons .nav-btn {
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      cursor: pointer;
      transition: all .2s ease;
    }
    nav.nav-buttons .nav-btn .bi {
      font-size: 1.1rem;
    }
    nav.nav-buttons .nav-btn:hover,
    nav.nav-buttons .nav-btn:focus {
      background: rgba(13,202,240,.12);
      border-color: rgba(13,202,240,.5);
      outline: none;
    }
    nav.nav-buttons .nav-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #031420;
      box-shadow: 0 0 0 0.15rem rgba(13,202,240,.25);
    }
    .mobile-launcher {
      display: none;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 0 1.5rem 1rem;
      gap: 0.75rem;
    }
    .mobile-launcher .mobile-group-title {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }
    .mobile-launcher .mobile-subgrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.6rem;
    }
    .mobile-tile {
      border: 1px solid rgba(13,202,240,.25);
      border-radius: 0.9rem;
      background: linear-gradient(135deg, rgba(13,202,240,.18), rgba(13,202,240,.05));
      color: var(--text);
      padding: 1rem 1.1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      width: 100%;
      text-align: left;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .mobile-tile .tile-text {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .mobile-tile .tile-title {
      font-size: 1.05rem;
      font-weight: 600;
    }
    .mobile-tile small {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .mobile-tile .bi {
      font-size: 1.5rem;
      color: var(--accent);
    }
    .mobile-tile:hover,
    .mobile-tile:focus {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 0.5rem 1.2rem rgba(3, 20, 32, 0.45);
      outline: none;
    }
    .mobile-tile.sub {
      background: #10243d;
      border-color: #1f3a5f;
      padding: 0.85rem 1rem;
    }
    .mobile-tile.sub .tile-title { font-size: 0.95rem; }
    .mobile-tile.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 0.15rem rgba(13,202,240,.3);
    }
    .frame-wrap {
      flex: 1;
      min-height: 0;
      padding: 0.75rem 1.5rem 1.5rem;
    }
    .frame-wrap iframe {
      width: 100%;
      height: 100%;
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      background: var(--panel);
    }
    footer.app-footer {
      padding: 0.5rem 1.5rem 1rem;
      font-size: 0.8rem;
      color: var(--muted);
      text-align: right;
    }
    @media (max-width: 900px) {
      header.app-header {
        padding: 0.85rem 1rem 0.65rem;
      }
      .mobile-launcher {
        padding: 0 1rem 0.85rem;
      }
      .frame-wrap {
        padding: 0.5rem 1rem 1rem;
      }
      footer.app-footer {
        padding: 0.5rem 1rem 1rem;
      }
    }
    @media (max-width: 720px) {
      header.app-header {
        flex-direction: column;
        align-items: flex-start;
      }
      header.app-header h1 { font-size: 1.25rem; }
      nav.nav-buttons { width: 100%; justify-content: flex-start; display: none; }
      .mobile-launcher { display: grid; }
      .frame-wrap { padding: 0.5rem 0.75rem 1rem; }
      footer.app-footer { padding: 0.5rem 0.75rem 1rem; text-align: left; }
    }
  </style>
</head>
<body>
<div class="head-wrap">
  <header class="app-header">
    <div class="brand">
      <h1><i class="bi bi-shield-lock-fill"></i> Akuvox Access Control</h1>
      <span class="version-badge" id="appVersion">Loadingâ€¦</span>
    </div>
    <nav class="nav-buttons" aria-label="Primary navigation">
      <button class="nav-btn" data-view="index">
        <i class="bi bi-speedometer2"></i>
        <span>Overview</span>
      </button>
      <button class="nav-btn" data-view="users">
        <i class="bi bi-people-fill"></i>
        <span>User Management</span>
      </button>
      <button class="nav-btn" data-view="device-edit">
        <i class="bi bi-hdd-network"></i>
        <span>Device Management</span>
      </button>
      <button class="nav-btn" data-view="settings">
        <i class="bi bi-gear-wide-connected"></i>
        <span>Global Settings</span>
      </button>
    </nav>
  </header>
  <section class="mobile-launcher" id="mobileLauncher" aria-label="Quick actions">
    <div>
      <div class="mobile-group-title">User management</div>
      <button class="mobile-tile" data-view="index" data-section="users">
        <div class="tile-text">
          <span class="tile-title">User management</span>
          <small>Review access levels and sync state</small>
        </div>
        <i class="bi bi-people-fill"></i>
      </button>
      <div class="mobile-subgrid">
        <button class="mobile-tile sub" data-view="users" data-mode="add">
          <div class="tile-text">
            <span class="tile-title">Add user</span>
            <small>Create a new access profile</small>
          </div>
          <i class="bi bi-person-plus-fill"></i>
        </button>
        <button class="mobile-tile sub" data-view="users" data-mode="edit">
          <div class="tile-text">
            <span class="tile-title">Edit user</span>
            <small>Pick someone to update or revoke access</small>
          </div>
          <i class="bi bi-person-check-fill"></i>
        </button>
      </div>
    </div>
    <button class="mobile-tile" data-view="index" data-section="devices">
      <div class="tile-text">
        <span class="tile-title">Device management</span>
        <small>Check health, reboot or sync panels</small>
      </div>
      <i class="bi bi-hdd-network"></i>
    </button>
    <button class="mobile-tile" data-view="index" data-section="events">
      <div class="tile-text">
        <span class="tile-title">Event history</span>
        <small>See the latest entries and alarms</small>
      </div>
      <i class="bi bi-clock-history"></i>
    </button>
    <button class="mobile-tile" data-view="settings">
      <div class="tile-text">
        <span class="tile-title">Global settings</span>
        <small>Tune schedules, relays and automation</small>
      </div>
      <i class="bi bi-sliders"></i>
    </button>
  </section>
  <div class="frame-wrap">
    <iframe id="viewFrame" title="Akuvox Access Control" src="about:blank" allow="clipboard-write"></iframe>
  </div>
  <footer class="app-footer" id="appFooter">&nbsp;</footer>
</div>

<script>
(function captureToken(){
  const params = new URLSearchParams(location.search);
  const token = params.get('token');
  if (token) {
    sessionStorage.setItem('akuvox_ll_token', token);
    params.delete('token');
    const rest = params.toString();
    const cleanUrl = rest ? `${location.pathname}?${rest}` : location.pathname;
    history.replaceState(history.state || {}, '', cleanUrl);
  }
})();

const UI_ROOT = '/akuvox-ac';
const DEFAULT_VIEW = 'index';

function getToken(){
  return sessionStorage.getItem('akuvox_ll_token') || null;
}

function persistTokens(access, refresh) {
  if (!access) return null;
  const payload = { access_token: access };
  if (refresh) payload.refresh_token = refresh;
  try { sessionStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  try { localStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  return access;
}

function extractTokenFromAuth(auth) {
  if (!auth || typeof auth !== 'object') return null;
  const access = auth.accessToken
    || auth.access_token
    || auth?.token?.access_token
    || auth?.data?.access_token
    || null;
  const refresh = auth.refreshToken
    || auth.refresh_token
    || auth?.token?.refresh_token
    || auth?.data?.refresh_token
    || null;
  if (access) {
    return persistTokens(access, refresh);
  }
  return null;
}

function scanTokenStorage(storage) {
  if (!storage) return null;
  try {
    const raw = storage.getItem('hassTokens');
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {
        if (typeof raw === 'string' && raw.trim()) {
          return persistTokens(raw.trim());
        }
      }
    }
    for (const key of Object.keys(storage)) {
      if (!/auth|token|hass/i.test(key)) continue;
      try {
        const parsed = JSON.parse(storage.getItem(key));
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {}
    }
  } catch (err) {}
  return null;
}

function tokenFromWindow(win) {
  if (!win) return null;
  let token = null;
  token = scanTokenStorage(win.sessionStorage) || scanTokenStorage(win.localStorage);
  if (token) return token;

  token = extractTokenFromAuth(win.hassAuth)
    || extractTokenFromAuth(win.auth)
    || extractTokenFromAuth(win.AK_AC_HA_AUTH)
    || null;
  if (token) return token;

  try {
    const conn = win.hassConnection;
    if (conn && typeof conn.then === 'function') {
      conn.then((resolved) => {
        try {
          extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
        } catch (err) {}
      }).catch(() => {});
    } else if (conn) {
      token = extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      if (token) return token;
    }
  } catch (err) {}

  return null;
}

function walkAuthWindows(start) {
  const visited = new Set();
  let current = start;
  while (current && !visited.has(current)) {
    const token = tokenFromWindow(current);
    if (token) return token;
    visited.add(current);

    let next = null;
    try {
      next = current.parent;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    try {
      next = current.opener;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    break;
  }
  return null;
}

(function bootstrapAuthWatchers() {
  const seen = new WeakSet();
  function attach(win) {
    if (!win || seen.has(win)) return;
    seen.add(win);
    try { extractTokenFromAuth(win.hassAuth || win.auth || win.AK_AC_HA_AUTH); } catch (err) {}
    try {
      const conn = win.hassConnection;
      if (conn && typeof conn.then === 'function') {
        conn.then((resolved) => {
          try {
            extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
          } catch (err) {}
        }).catch(() => {});
      } else if (conn) {
        extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      }
    } catch (err) {}
    try {
      if (win.parent && win.parent !== win) attach(win.parent);
    } catch (err) {}
    try {
      if (win.opener) attach(win.opener);
    } catch (err) {}
  }
  attach(window);
})();

const AUTH_SIG_KEY = 'akuvox_auth_sig';

function readAuthSigFrom(search = location.search) {
  try {
    const params = new URLSearchParams(search);
    const value = params.get('authSig');
    return value || '';
  } catch (err) {
    return '';
  }
}

function rememberAuthSig(value) {
  if (!value) return;
  try { sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { window.AK_AC_AUTH_SIG = value; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      try { window.parent.sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { window.parent.localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { window.parent.AK_AC_AUTH_SIG = value; } catch (err) {}
    }
  } catch (err) {}
}

function currentAuthSig() {
  const fromUrl = readAuthSigFrom();
  if (fromUrl) {
    rememberAuthSig(fromUrl);
    return fromUrl;
  }

  const sources = [
    () => {
      try { return sessionStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return localStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return window.AK_AC_AUTH_SIG || null; } catch (err) { return null; }
    },
    () => {
      try {
        if (window.parent && window.parent !== window) {
          const parent = window.parent;
          return parent.AK_AC_AUTH_SIG
            || (parent.sessionStorage && parent.sessionStorage.getItem(AUTH_SIG_KEY))
            || (parent.localStorage && parent.localStorage.getItem(AUTH_SIG_KEY));
        }
      } catch (err) {}
      return null;
    }
  ];

  for (const getter of sources) {
    const value = getter();
    if (value) {
      rememberAuthSig(value);
      return value;
    }
  }

  return '';
}

rememberAuthSig(readAuthSigFrom());
window.AK_AC_AUTH_SIG = currentAuthSig();

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_STATE = signedPath('state', '/api/akuvox_ac/ui/state');

function buildUrl(view, params = {}){
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([k,v]) => {
    if (v !== undefined && v !== null && v !== '') search.set(k, v);
  });
  const token = getToken();
  if (token) search.set('token', token);
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const slug = view.replace(/_/g,'-');
  return `${UI_ROOT}/${slug}${query ? `?${query}` : ''}`;
}

function normalizeView(view){
  let v = String(view || '').trim();
  if (!v) return DEFAULT_VIEW;
  v = v.replace(/\.html$/i, '').replace(/_/g, '-');
  if (v === 'dashboard') return 'index';
  if (v === 'face-rec') return 'face-rec';
  if (v === 'device-edit') return 'device-edit';
  if (v === 'users') return 'users';
  if (v === 'schedules') return 'schedules';
  return v || DEFAULT_VIEW;
}

function paramsFromSearch(search){
  const out = {};
  const sp = new URLSearchParams(search || location.search);
  sp.forEach((value, key) => {
    if (key === 'view') return;
    out[key] = value;
  });
  return out;
}

function setActiveNav(view){
  let frameParams = null;
  try {
    const frame = document.getElementById('viewFrame');
    if (frame && frame.dataset && frame.dataset.currentHref) {
      frameParams = new URL(frame.dataset.currentHref, window.location.origin);
    }
  } catch (err) {
    frameParams = null;
  }
  const activeMode = frameParams ? (frameParams.searchParams.get('mode') || '') : '';
  const hasUserId = frameParams ? frameParams.searchParams.has('id') : false;
  const currentSection = frameParams ? (frameParams.searchParams.get('section') || '') : '';

  document.querySelectorAll('nav.nav-buttons .nav-btn').forEach(btn => {
    const target = normalizeView(btn.dataset.view);
    if (target === view) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  document.querySelectorAll('.mobile-launcher [data-view]').forEach(btn => {
    const target = normalizeView(btn.dataset.view);
    let isActive = target === view;
    if (isActive && target === 'users') {
      const btnMode = (btn.dataset.mode || '').toLowerCase();
      if (btnMode === 'edit') {
        isActive = hasUserId || activeMode === 'edit';
      } else if (btnMode === 'add') {
        isActive = !hasUserId && activeMode !== 'edit';
      }
    } else if (isActive && target === 'index') {
      const btnSection = (btn.dataset.section || '').toLowerCase();
      if (btnSection) {
        isActive = currentSection.toLowerCase() === btnSection;
      }
    }
    if (isActive) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}

function updateHistory(view, params, { replaceState = false } = {}){
  const state = { view, params };
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([k,v]) => {
    if (v !== undefined && v !== null && v !== '') search.set(k, v);
  });
  if (view !== DEFAULT_VIEW) search.set('view', view);
  else search.delete('view');
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const url = query ? `${location.pathname}?${query}` : location.pathname;
  if (replaceState) history.replaceState(state, '', url);
  else history.pushState(state, '', url);
}

function loadView(view, params = {}, options = {}){
  const normalized = normalizeView(view);
  const href = buildUrl(normalized, params);
  const frame = document.getElementById('viewFrame');
  if (frame.dataset.currentHref !== href) {
    frame.src = href;
    frame.dataset.currentHref = href;
  }
  setActiveNav(normalized);
  if (options.updateHistory !== false) {
    updateHistory(normalized, params, { replaceState: !!options.replaceState });
  }
}

function paramsFromButton(btn){
  const params = {};
  if (!btn || !btn.dataset) return params;
  const { section, mode, id } = btn.dataset;
  if (section) params.section = section;
  if (mode) params.mode = mode;
  if (id) params.id = id;
  return params;
}

async function fetchVersion(){
  const badge = document.getElementById('appVersion');
  const footer = document.getElementById('appFooter');
  const token = getToken();
  const headers = token ? { 'Authorization': 'Bearer ' + token } : {};
  try {
    const res = await fetch(API_STATE, {
      credentials: 'same-origin',
      headers
    });
    if (!res.ok) throw new Error(await res.text());
    const data = await res.json();
    const label = data?.kpis?.version || 'â€”';
    badge.textContent = label;
    const raw = data?.kpis?.version_raw || '';
    footer.textContent = raw ? `Integration version ${label} (${raw})` : `Integration version ${label}`;
  } catch (err) {
    badge.textContent = 'Version unavailable';
    footer.textContent = 'Unable to load version information';
  }
}

document.querySelectorAll('nav.nav-buttons .nav-btn').forEach(btn => {
  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    const view = normalizeView(btn.dataset.view);
    const params = paramsFromButton(btn);
    loadView(view, params, { replaceState: false });
  });
});

document.querySelectorAll('.mobile-launcher [data-view]').forEach(btn => {
  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    const view = normalizeView(btn.dataset.view);
    const params = paramsFromButton(btn);
    loadView(view, params, { replaceState: false });
  });
});

window.addEventListener('message', (event) => {
  if (event.origin !== window.location.origin) return;
  const data = event.data || {};
  if (data.type !== 'akuvox-nav') return;
  const view = normalizeView(data.view || data.slug || data.target || DEFAULT_VIEW);
  const params = data.params || {};
  const opts = {
    updateHistory: data.updateHistory !== false,
    replaceState: !!data.replaceState
  };
  loadView(view, params, opts);
});

window.addEventListener('popstate', (event) => {
  const state = event.state || {};
  const view = normalizeView(state.view || new URLSearchParams(location.search).get('view') || DEFAULT_VIEW);
  const params = state.params || paramsFromSearch(location.search);
  loadView(view, params, { updateHistory: false });
});

(function init(){
  const searchParams = new URLSearchParams(location.search);
  const initialView = normalizeView(searchParams.get('view') || DEFAULT_VIEW);
  const params = paramsFromSearch(location.search);
  loadView(initialView, params, { replaceState: true });
  fetchVersion();
})();
</script>
</body>
</html>
