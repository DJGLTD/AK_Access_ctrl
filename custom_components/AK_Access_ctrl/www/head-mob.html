<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox Access Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"/>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" crossorigin="anonymous"/>
  <style>
    :root {
      --bg:#0b1320; --panel:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc;
      --accent:#2ff0c4; --accent-dark:#1ba987;
      --mint:#2ff0c4; --mint-soft:rgba(47,240,196,.18); --mint-glow:rgba(47,240,196,.35);
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    .head-wrap {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header.app-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem 0.75rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 1rem;
      z-index: 2;
    }
    header.app-header .brand {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    header.app-header h1 {
      font-size: 1.25rem;
      margin: 0;
    }
    header.app-header .logo-mark {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2.75rem;
      height: 2.75rem;
      border-radius: 0.9rem;
      background: linear-gradient(135deg, var(--mint), rgba(132,255,231,.85));
      box-shadow: 0 0.6rem 1.2rem rgba(47,240,196,.22);
      position: relative;
      overflow: hidden;
    }
    header.app-header .logo-mark::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.35), rgba(255,255,255,0));
      pointer-events: none;
    }
    header.app-header .logo-mark .bi {
      font-size: 1.35rem;
      color: #031d21;
      position: relative;
      z-index: 1;
    }
    nav.nav-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    nav.nav-buttons .nav-btn {
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      cursor: pointer;
      transition: all .2s ease;
    }
    nav.nav-buttons .nav-btn .bi {
      font-size: 1.1rem;
    }
    nav.nav-buttons .nav-btn:hover,
    nav.nav-buttons .nav-btn:focus {
      background: rgba(13,202,240,.12);
      border-color: rgba(13,202,240,.5);
      outline: none;
    }
    nav.nav-buttons .nav-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #031420;
      box-shadow: 0 0 0 0.15rem rgba(47,240,196,.28);
    }
    .nav-quick-actions {
      display: none;
      width: 100%;
      margin-top: 0.35rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .nav-quick-actions.active { display: flex; }
    .nav-quick-actions .quick-group {
      display: none;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .nav-quick-actions .quick-group.expanded { display: flex; }
    .nav-quick-actions .quick-btn {
      border-radius: 0.75rem;
      border: 1px solid var(--mint-glow);
      background: var(--mint-soft);
      color: var(--text);
      padding: 0.35rem 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all .2s ease;
    }
    .nav-quick-actions .quick-btn .bi {
      color: var(--mint);
      font-size: 1rem;
    }
    .nav-quick-actions .quick-btn:hover,
    .nav-quick-actions .quick-btn:focus {
      background: rgba(47,240,196,.25);
      border-color: rgba(47,240,196,.6);
      outline: none;
    }
    .mobile-launcher {
      display: none;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 0 1.5rem 1rem;
      gap: 0.75rem;
    }
    .mobile-group {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .mobile-group + .mobile-group { margin-top: 0.5rem; }
    .mobile-launcher .mobile-subgrid {
      display: none;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.6rem;
    }
    .mobile-group.expanded .mobile-subgrid { display: grid; }
    .mobile-group [data-group-toggle] {
      border: 1px solid rgba(47,240,196,.25);
    }
    .mobile-group.expanded [data-group-toggle] {
      border-color: rgba(47,240,196,.55);
      box-shadow: 0 0.8rem 1.5rem rgba(3,20,32,.55);
    }
    .mobile-tile {
      border: 1px solid rgba(13,202,240,.25);
      border-radius: 0.9rem;
      background: linear-gradient(135deg, rgba(13,202,240,.18), rgba(13,202,240,.05));
      color: var(--text);
      padding: 1rem 1.1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      width: 100%;
      text-align: left;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .mobile-tile .tile-text {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .mobile-tile .tile-title {
      font-size: 1.05rem;
      font-weight: 600;
    }
    .mobile-tile small {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .mobile-tile .bi {
      font-size: 1.5rem;
      color: var(--accent);
    }
    .mobile-tile:hover,
    .mobile-tile:focus {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 0.5rem 1.2rem rgba(3, 20, 32, 0.45);
      outline: none;
    }
    .mobile-tile.sub {
      background: #10243d;
      border-color: #1f3a5f;
      padding: 0.85rem 1rem;
    }
    .mobile-tile.sub .tile-title { font-size: 0.95rem; }
    .mobile-tile.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 0.15rem rgba(13,202,240,.3);
    }
    .frame-wrap {
      flex: 1;
      min-height: 0;
      padding: 0.75rem 1.5rem 1.5rem;
    }
    .frame-wrap iframe {
      width: 100%;
      height: 100%;
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      background: var(--panel);
    }
    footer.app-footer {
      padding: 0.5rem 1.5rem 1rem;
      font-size: 0.8rem;
      color: var(--muted);
      text-align: right;
    }
    .mobile-back-btn {
      display: none;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 0.4rem 0.95rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all .2s ease;
    }
    .mobile-back-btn .bi {
      font-size: 1.1rem;
    }
    .mobile-back-btn:focus,
    .mobile-back-btn:hover {
      background: rgba(13,202,240,.12);
      border-color: rgba(13,202,240,.5);
      outline: none;
    }
    @media (max-width: 900px) {
      header.app-header {
        padding: 0.85rem 1rem 0.65rem;
      }
      .mobile-launcher {
        padding: 0 1rem 0.85rem;
      }
      .frame-wrap {
        padding: 0.5rem 1rem 1rem;
      }
      footer.app-footer {
        padding: 0.5rem 1rem 1rem;
      }
    }
    @media (max-width: 720px) {
      header.app-header {
        flex-direction: column;
        align-items: flex-start;
      }
      header.app-header h1 { font-size: 1.25rem; }
      nav.nav-buttons { width: 100%; justify-content: flex-start; display: none; }
      .nav-quick-actions { display: none !important; }
      .mobile-launcher { display: grid; }
      .frame-wrap { padding: 0.5rem 0.75rem 1rem; }
      footer.app-footer { padding: 0.5rem 0.75rem 1rem; text-align: left; }
      body.mobile-stage-nav .frame-wrap,
      body.mobile-stage-nav footer.app-footer { display: none; }
      body.mobile-stage-nav .mobile-launcher { display: grid; }
      body.mobile-stage-content .mobile-launcher { display: none; }
      body.mobile-stage-content .frame-wrap,
      body.mobile-stage-content footer.app-footer { display: block; }
      body.mobile-stage-content .mobile-back-btn { display: inline-flex; }
    }
  </style>
</head>
<body>
<div class="head-wrap">
  <header class="app-header">
    <div class="brand">
      <h1 class="visually-hidden">Akuvox Access Control</h1>
      <span class="logo-mark" aria-hidden="true"><i class="bi bi-shield-lock-fill"></i></span>
    </div>
    <button class="mobile-back-btn" type="button" id="mobileBackBtn">
      <i class="bi bi-chevron-left"></i>
      <span>Back</span>
    </button>
    <nav class="nav-buttons" aria-label="Primary navigation">
      <button class="nav-btn" type="button" data-view="index">
        <i class="bi bi-speedometer2"></i>
        <span>Overview</span>
      </button>
      <button class="nav-btn" type="button" data-view="users" data-group-toggle="users">
        <i class="bi bi-people-fill"></i>
        <span>User Management</span>
      </button>
      <button class="nav-btn" type="button" data-view="index" data-section="global-actions" data-group-toggle="global">
        <i class="bi bi-lightning-fill"></i>
        <span>Global Actions</span>
      </button>
      <button class="nav-btn" type="button" data-view="device-edit">
        <i class="bi bi-hdd-network"></i>
        <span>Device Management</span>
      </button>
      <button class="nav-btn" type="button" data-view="settings">
        <i class="bi bi-gear-wide-connected"></i>
        <span>Global Settings</span>
      </button>
    </nav>
    <div class="nav-quick-actions" id="navQuickActions">
      <div class="quick-group" data-group="users">
        <button type="button" class="quick-btn" data-view="users" data-mode="add">
          <i class="bi bi-person-plus-fill"></i>
          <span>Add user</span>
        </button>
        <button type="button" class="quick-btn" data-view="users" data-mode="edit">
          <i class="bi bi-person-gear"></i>
          <span>Edit user</span>
        </button>
      </div>
      <div class="quick-group" data-group="global">
        <button type="button" class="quick-btn" data-action="reboot_all">
          <i class="bi bi-arrow-repeat"></i>
          <span>Reboot all</span>
        </button>
        <button type="button" class="quick-btn" data-action="force_full_sync">
          <i class="bi bi-lightning-charge-fill"></i>
          <span>Force full sync</span>
        </button>
      </div>
    </div>
  </header>
  <section class="mobile-launcher" id="mobileLauncher" aria-label="Quick actions">
    <div class="mobile-group" data-group="users">
      <button class="mobile-tile" type="button" data-group-toggle="users" aria-expanded="false">
        <div class="tile-text">
          <span class="tile-title">User management</span>
          <small>Review access levels and sync state</small>
        </div>
        <i class="bi bi-people-fill"></i>
      </button>
      <div class="mobile-subgrid">
        <button class="mobile-tile sub" type="button" data-view="index" data-section="users">
          <div class="tile-text">
            <span class="tile-title">User overview</span>
            <small>See device sync and assigned groups</small>
          </div>
          <i class="bi bi-layout-text-window-reverse"></i>
        </button>
        <button class="mobile-tile sub" type="button" data-view="users" data-mode="add">
          <div class="tile-text">
            <span class="tile-title">Add user</span>
            <small>Create a new access profile</small>
          </div>
          <i class="bi bi-person-plus-fill"></i>
        </button>
        <button class="mobile-tile sub" type="button" data-view="users" data-mode="edit">
          <div class="tile-text">
            <span class="tile-title">Edit user</span>
            <small>Pick someone to update or revoke access</small>
          </div>
          <i class="bi bi-person-check-fill"></i>
        </button>
      </div>
    </div>
    <div class="mobile-group" data-group="global">
      <button class="mobile-tile" type="button" data-group-toggle="global" aria-expanded="false">
        <div class="tile-text">
          <span class="tile-title">Global actions</span>
          <small>Trigger device-wide jobs</small>
        </div>
        <i class="bi bi-lightning-fill"></i>
      </button>
      <div class="mobile-subgrid">
        <button class="mobile-tile sub" type="button" data-view="index" data-section="global-actions">
          <div class="tile-text">
            <span class="tile-title">Action dashboard</span>
            <small>Open system-wide controls</small>
          </div>
          <i class="bi bi-speedometer"></i>
        </button>
        <button class="mobile-tile sub" type="button" data-action="reboot_all">
          <div class="tile-text">
            <span class="tile-title">Reboot all</span>
            <small>Restart every connected panel</small>
          </div>
          <i class="bi bi-arrow-repeat"></i>
        </button>
        <button class="mobile-tile sub" type="button" data-action="force_full_sync">
          <div class="tile-text">
            <span class="tile-title">Force full sync</span>
            <small>Refresh credentials everywhere</small>
          </div>
          <i class="bi bi-lightning-charge-fill"></i>
        </button>
      </div>
    </div>
    <button class="mobile-tile" type="button" data-view="index" data-section="devices">
      <div class="tile-text">
        <span class="tile-title">Device management</span>
        <small>Check health, reboot or sync panels</small>
      </div>
      <i class="bi bi-hdd-network"></i>
    </button>
    <button class="mobile-tile" type="button" data-view="index" data-section="events">
      <div class="tile-text">
        <span class="tile-title">Event history</span>
        <small>See the latest entries and alarms</small>
      </div>
      <i class="bi bi-clock-history"></i>
    </button>
    <button class="mobile-tile" type="button" data-view="settings">
      <div class="tile-text">
        <span class="tile-title">Global settings</span>
        <small>Tune schedules, relays and automation</small>
      </div>
      <i class="bi bi-sliders"></i>
    </button>
  </section>
  <div class="frame-wrap">
    <iframe id="viewFrame" title="Akuvox Access Control" src="about:blank" allow="clipboard-write"></iframe>
  </div>
  <footer class="app-footer" id="appFooter">&nbsp;</footer>
</div>

<script>
(function captureToken(){
  const params = new URLSearchParams(location.search);
  const token = params.get('token');
  if (token) {
    rememberToken(token);
    params.delete('token');
    const rest = params.toString();
    const cleanUrl = rest ? `${location.pathname}?${rest}` : location.pathname;
    history.replaceState(history.state || {}, '', cleanUrl);
  }
})();

const UI_ROOT = '/akuvox-ac';
const DEFAULT_VIEW = 'index';
let expandedGroup = null;
const MOBILE_BREAKPOINT = '(max-width: 720px)';
const mobileMedia = window.matchMedia(MOBILE_BREAKPOINT);
let isMobileMode = mobileMedia.matches;
let mobileStage = isMobileMode ? 'nav' : 'content';
let knownToken = null;
let tokenRefreshScheduled = false;

function scheduleTokenRefresh(){
  if (tokenRefreshScheduled) return;
  tokenRefreshScheduled = true;
  const run = () => {
    tokenRefreshScheduled = false;
    try { handleTokenChanged(); } catch (err) {}
  };
  if (typeof queueMicrotask === 'function') queueMicrotask(run);
  else setTimeout(run, 0);
}

function rememberToken(value) {
  const token = typeof value === 'string' ? value.trim() : '';
  if (!token) return null;
  const changed = token !== knownToken;
  knownToken = token;
  try { sessionStorage.setItem('akuvox_ll_token', token); } catch (err) {}
  try { localStorage.setItem('akuvox_ll_token', token); } catch (err) {}
  try { window.AK_AC_HA_TOKEN = token; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      try { window.parent.AK_AC_HA_TOKEN = token; } catch (err) {}
      try { window.parent.sessionStorage.setItem('akuvox_ll_token', token); } catch (err) {}
      try { window.parent.localStorage.setItem('akuvox_ll_token', token); } catch (err) {}
    }
  } catch (err) {}
  if (changed) scheduleTokenRefresh();
  return token;
}

function getToken(){
  if (knownToken) return knownToken;
  let stored = null;
  try { stored = sessionStorage.getItem('akuvox_ll_token'); } catch (err) {
    stored = null;
  }
  if (stored) {
    knownToken = stored;
    return stored;
  }
  try {
    const local = localStorage.getItem('akuvox_ll_token');
    if (local) return rememberToken(local);
  } catch (err) {}
  try {
    const direct = window.AK_AC_HA_TOKEN || window.AK_AC_TOKEN || null;
    if (typeof direct === 'string' && direct.trim()) return rememberToken(direct.trim());
  } catch (err) {}
  let discovered = null;
  try {
    discovered = walkAuthWindows(window);
  } catch (err) {
    discovered = null;
  }
  if (discovered) {
    rememberToken(discovered);
    return discovered;
  }
  return null;
}

function persistTokens(access, refresh) {
  if (!access) return null;
  const payload = { access_token: access };
  if (refresh) payload.refresh_token = refresh;
  try { sessionStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  try { localStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  try { window.AK_AC_HA_AUTH = payload; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      try { window.parent.AK_AC_HA_AUTH = payload; } catch (err) {}
      try { window.parent.localStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
    }
  } catch (err) {}
  return rememberToken(access);
}

function extractTokenFromAuth(auth) {
  if (!auth || typeof auth !== 'object') return null;
  const access = auth.accessToken
    || auth.access_token
    || auth?.token?.access_token
    || auth?.data?.access_token
    || null;
  const refresh = auth.refreshToken
    || auth.refresh_token
    || auth?.token?.refresh_token
    || auth?.data?.refresh_token
    || null;
  if (access) {
    return persistTokens(access, refresh);
  }
  return null;
}

function scanTokenStorage(storage) {
  if (!storage) return null;
  try {
    const raw = storage.getItem('hassTokens');
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {
        if (typeof raw === 'string' && raw.trim()) {
          return persistTokens(raw.trim());
        }
      }
    }
    for (const key of Object.keys(storage)) {
      if (!/auth|token|hass/i.test(key)) continue;
      if (/authsig/i.test(key)) continue;
      let rawValue = null;
      try {
        rawValue = storage.getItem(key);
      } catch (err) {
        rawValue = null;
      }
      if (!rawValue) continue;
      try {
        const parsed = JSON.parse(rawValue);
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {
        if (typeof rawValue === 'string' && rawValue.trim()) {
          const token = persistTokens(rawValue.trim());
          if (token) return token;
        }
      }
    }
  } catch (err) {}
  return null;
}

function tokenFromWindow(win) {
  if (!win) return null;
  let token = null;
  token = scanTokenStorage(win.sessionStorage) || scanTokenStorage(win.localStorage);
  if (token) return token;

  token = extractTokenFromAuth(win.hassAuth)
    || extractTokenFromAuth(win.auth)
    || extractTokenFromAuth(win.AK_AC_HA_AUTH)
    || extractTokenFromAuth(win.AK_AC_HA_AUTH?.data)
    || null;
  if (token) return token;

  try {
    const direct = win.AK_AC_HA_TOKEN || win.AK_AC_TOKEN || null;
    if (typeof direct === 'string' && direct.trim()) {
      const persisted = rememberToken(direct.trim());
      if (persisted) return persisted;
    }
  } catch (err) {}

  try {
    const conn = win.hassConnection;
    if (conn && typeof conn.then === 'function') {
      conn.then((resolved) => {
        try {
          extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
        } catch (err) {}
      }).catch(() => {});
    } else if (conn) {
      token = extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      if (token) return token;
    }
  } catch (err) {}

  return null;
}

function walkAuthWindows(start) {
  const visited = new Set();
  let current = start;
  while (current && !visited.has(current)) {
    const token = tokenFromWindow(current);
    if (token) return token;
    visited.add(current);

    let next = null;
    try {
      next = current.parent;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    try {
      next = current.opener;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    break;
  }
  return null;
}

(function bootstrapAuthWatchers() {
  const seen = new WeakSet();
  function attach(win) {
    if (!win || seen.has(win)) return;
    seen.add(win);
    try { extractTokenFromAuth(win.hassAuth || win.auth || win.AK_AC_HA_AUTH); } catch (err) {}
    try {
      const conn = win.hassConnection;
      if (conn && typeof conn.then === 'function') {
        conn.then((resolved) => {
          try {
            extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
          } catch (err) {}
        }).catch(() => {});
      } else if (conn) {
        extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      }
    } catch (err) {}
    try {
      if (win.parent && win.parent !== win) attach(win.parent);
    } catch (err) {}
    try {
      if (win.opener) attach(win.opener);
    } catch (err) {}
  }
  attach(window);
})();

function applyMobileFlags(){
  const body = document.body;
  if (!body) return;
  body.classList.toggle('mobile-mode', isMobileMode);
  body.classList.toggle('mobile-stage-nav', isMobileMode && mobileStage === 'nav');
  body.classList.toggle('mobile-stage-content', !isMobileMode || mobileStage === 'content');
}

function syncHistoryStage(forceStage){
  try {
    const current = history.state || {};
    const nextStage = typeof forceStage === 'string' && forceStage
      ? forceStage
      : (isMobileMode ? mobileStage : 'content');
    const nextState = { ...current, mobileStage: nextStage };
    history.replaceState(nextState, '', location.href);
  } catch (err) {}
}

function setMobileStage(stage, { preserveGroups = false } = {}){
  if (!isMobileMode) {
    mobileStage = 'content';
    return;
  }
  mobileStage = stage === 'content' ? 'content' : 'nav';
  if (mobileStage === 'nav' && !preserveGroups) {
    expandedGroup = null;
  }
  applyMobileFlags();
  updateGroupExpansion();
  syncHistoryStage();
}

function handleMobileMediaChange(ev){
  const nextIsMobile = !!ev.matches;
  if (nextIsMobile === isMobileMode) {
    return;
  }
  isMobileMode = nextIsMobile;
  if (isMobileMode) {
    mobileStage = 'nav';
    applyMobileFlags();
    updateGroupExpansion();
    syncHistoryStage('nav');
  } else {
    mobileStage = 'content';
    applyMobileFlags();
    updateGroupExpansion();
    syncHistoryStage('content');
  }
  reloadActiveView({ updateHistory: false });
}

applyMobileFlags();
if (typeof mobileMedia.addEventListener === 'function') {
  mobileMedia.addEventListener('change', handleMobileMediaChange);
} else if (typeof mobileMedia.addListener === 'function') {
  mobileMedia.addListener(handleMobileMediaChange);
}

const AUTH_SIG_KEY = 'akuvox_auth_sig';

function readAuthSigFrom(search = location.search) {
  try {
    const params = new URLSearchParams(search);
    const value = params.get('authSig');
    return value || '';
  } catch (err) {
    return '';
  }
}

function rememberAuthSig(value) {
  if (!value) return;
  try { sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { window.AK_AC_AUTH_SIG = value; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      try { window.parent.sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { window.parent.localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { window.parent.AK_AC_AUTH_SIG = value; } catch (err) {}
    }
  } catch (err) {}
}

function currentAuthSig() {
  const fromUrl = readAuthSigFrom();
  if (fromUrl) {
    rememberAuthSig(fromUrl);
    return fromUrl;
  }

  const sources = [
    () => {
      try { return sessionStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return localStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return window.AK_AC_AUTH_SIG || null; } catch (err) { return null; }
    },
    () => {
      try {
        if (window.parent && window.parent !== window) {
          const parent = window.parent;
          return parent.AK_AC_AUTH_SIG
            || (parent.sessionStorage && parent.sessionStorage.getItem(AUTH_SIG_KEY))
            || (parent.localStorage && parent.localStorage.getItem(AUTH_SIG_KEY));
        }
      } catch (err) {}
      return null;
    }
  ];

  for (const getter of sources) {
    const value = getter();
    if (value) {
      rememberAuthSig(value);
      return value;
    }
  }

  return '';
}

rememberAuthSig(readAuthSigFrom());
window.AK_AC_AUTH_SIG = currentAuthSig();

if (typeof window.addEventListener === 'function') {
  window.addEventListener('storage', (event) => {
    if (!event) return;
    const key = event.key || '';
    if (!key) return;
    if (key === 'hassTokens') {
      const value = event.newValue;
      if (!value) return;
      try {
        const parsed = JSON.parse(value);
        extractTokenFromAuth(parsed);
      } catch (err) {
        if (typeof value === 'string' && value.trim()) rememberToken(value.trim());
      }
      return;
    }
    if (key === 'akuvox_ll_token') {
      if (typeof event.newValue === 'string' && event.newValue.trim()) rememberToken(event.newValue.trim());
      return;
    }
    if (key === AUTH_SIG_KEY) {
      if (typeof event.newValue === 'string' && event.newValue.trim()) rememberAuthSig(event.newValue.trim());
      return;
    }
    if (key === 'akuvox_signed_paths') {
      if (typeof event.newValue !== 'string' || !event.newValue.trim()) return;
      try {
        const parsed = JSON.parse(event.newValue);
        if (parsed && typeof parsed === 'object') {
          Object.assign(SIGNED_PATHS, parsed);
        }
      } catch (err) {}
    }
  });
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_STATE = signedPath('state', '/api/akuvox_ac/ui/state');

function buildUrl(view, params = {}){
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([k,v]) => {
    if (v !== undefined && v !== null && v !== '') search.set(k, v);
  });
  const token = getToken();
  if (token) search.set('token', token);
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const slug = view.replace(/_/g,'-');
  return `${UI_ROOT}/${slug}${query ? `?${query}` : ''}`;
}

function normalizeView(view){
  let v = String(view || '').trim();
  if (!v) return DEFAULT_VIEW;
  v = v.replace(/\.html$/i, '').replace(/_/g, '-');
  if (v === 'dashboard') return 'index';
  if (v === 'face-rec') return 'face-rec';
  if (v === 'device-edit') return 'device-edit';
  if (v === 'users') return 'users';
  if (v === 'schedules') return 'schedules';
  return v || DEFAULT_VIEW;
}

function paramsFromSearch(search){
  const out = {};
  const sp = new URLSearchParams(search || location.search);
  sp.forEach((value, key) => {
    if (key === 'view') return;
    out[key] = value;
  });
  return out;
}

function updateGroupExpansion(){
  document.querySelectorAll('[data-group]').forEach(group => {
    const key = group.dataset.group;
    if (!key) return;
    const expanded = expandedGroup === key;
    group.classList.toggle('expanded', expanded);
  });
  document.querySelectorAll('[data-group-toggle]').forEach(toggle => {
    const key = toggle.dataset.groupToggle;
    if (!key) return;
    const expanded = expandedGroup === key;
    toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
  });
  const quickContainer = document.getElementById('navQuickActions');
  if (quickContainer) {
    const hasExpanded = !!quickContainer.querySelector('.quick-group.expanded');
    quickContainer.classList.toggle('active', hasExpanded);
  }
}

function setActiveNav(view){
  let frameParams = null;
  try {
    const frame = document.getElementById('viewFrame');
    if (frame && frame.dataset && frame.dataset.currentHref) {
      frameParams = new URL(frame.dataset.currentHref, window.location.origin);
    }
  } catch (err) {
    frameParams = null;
  }
  const activeMode = frameParams ? (frameParams.searchParams.get('mode') || '') : '';
  const hasUserId = frameParams ? frameParams.searchParams.has('id') : false;
  const currentSection = frameParams ? (frameParams.searchParams.get('section') || '') : '';
  const sectionLower = currentSection.toLowerCase();

  document.querySelectorAll('nav.nav-buttons .nav-btn').forEach(btn => {
    const target = normalizeView(btn.dataset.view);
    let isActive = false;
    if (target === 'index') {
      if (view === 'index') {
        const btnSection = (btn.dataset.section || '').toLowerCase();
        if (btnSection) {
          isActive = sectionLower === btnSection;
        } else {
          isActive = !sectionLower;
        }
      }
    } else {
      isActive = target === view;
    }
    if (isActive) btn.classList.add('active');
    else btn.classList.remove('active');
  });

  document.querySelectorAll('.mobile-launcher [data-view]').forEach(btn => {
    const target = normalizeView(btn.dataset.view);
    let isActive = false;
    if (target === 'users') {
      if (view === 'users') {
        isActive = true;
        const btnMode = (btn.dataset.mode || '').toLowerCase();
        if (btnMode === 'edit') {
          isActive = hasUserId || activeMode === 'edit';
        } else if (btnMode === 'add') {
          isActive = !hasUserId && activeMode !== 'edit';
        }
      }
    } else if (target === 'index') {
      if (view === 'index') {
        const btnSection = (btn.dataset.section || '').toLowerCase();
        if (btnSection) {
          isActive = sectionLower === btnSection;
        } else {
          isActive = !sectionLower;
        }
      }
    } else {
      isActive = target === view;
    }
    if (isActive) btn.classList.add('active');
    else btn.classList.remove('active');
  });

  const userActive = view === 'users' || (view === 'index' && sectionLower === 'users');
  const globalActive = view === 'index' && sectionLower === 'global-actions';

  const allowAutoExpand = !(isMobileMode && mobileStage === 'nav');
  if (allowAutoExpand) {
    if (userActive) {
      expandedGroup = 'users';
    } else if (globalActive) {
      expandedGroup = 'global';
    } else if (expandedGroup) {
      expandedGroup = null;
    }
  }

  updateGroupExpansion();
}

function updateHistory(view, params, { replaceState = false } = {}){
  const state = { view, params, mobileStage: isMobileMode ? mobileStage : 'content' };
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([k,v]) => {
    if (v !== undefined && v !== null && v !== '') search.set(k, v);
  });
  if (view !== DEFAULT_VIEW) search.set('view', view);
  else search.delete('view');
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const url = query ? `${location.pathname}?${query}` : location.pathname;
  if (replaceState) history.replaceState(state, '', url);
  else history.pushState(state, '', url);
}

function loadView(view, params = {}, options = {}){
  const normalized = normalizeView(view);
  const frameParams = { ...(params || {}) };
  if (!('variant' in frameParams)) {
    frameParams.variant = isMobileMode ? 'mobile' : 'desktop';
  }
  const href = buildUrl(normalized, frameParams);
  const frame = document.getElementById('viewFrame');
  if (frame) {
    if (frame.dataset.currentHref !== href) {
      frame.src = href;
      frame.dataset.currentHref = href;
    }
    frame.dataset.currentView = normalized;
    frame.dataset.currentVariant = typeof frameParams.variant === 'string' ? frameParams.variant : '';
    try {
      frame.dataset.currentParams = JSON.stringify(params || {});
    } catch (err) {
      frame.dataset.currentParams = '{}';
    }
  }
  setActiveNav(normalized);
  if (options.updateHistory !== false) {
    updateHistory(normalized, params, { replaceState: !!options.replaceState });
  }
}

function reloadActiveView(options = {}){
  const frame = document.getElementById('viewFrame');
  if (!frame) return;
  const view = frame.dataset.currentView || DEFAULT_VIEW;
  let params = {};
  if (frame.dataset.currentParams) {
    try {
      params = JSON.parse(frame.dataset.currentParams);
    } catch (err) {
      params = {};
    }
  }
  loadView(view, params, { updateHistory: options.updateHistory ?? false, replaceState: !!options.replaceState });
}

function handleTokenChanged(){
  reloadActiveView({ updateHistory: false, replaceState: false });
  try { fetchVersion(); } catch (err) {}
}

function paramsFromButton(btn){
  const params = {};
  if (!btn || !btn.dataset) return params;
  const { section, mode, id } = btn.dataset;
  if (section) params.section = section;
  if (mode) params.mode = mode;
  if (id) params.id = id;
  return params;
}

function runDashboardAction(action){
  const normalized = String(action || '').toLowerCase();
  if (!normalized) return;
  const frame = document.getElementById('viewFrame');
  if (!frame) return;

  const previousHref = frame.dataset.currentHref;
  if (isMobileMode) setMobileStage('content', { preserveGroups: true });
  loadView('index', { section: 'global-actions' });
  const changed = frame.dataset.currentHref !== previousHref;

  const deliver = () => {
    try {
      frame.contentWindow?.postMessage({ type: 'akuvox-action', action: normalized }, window.location.origin);
    } catch (err) {
      console.warn('Failed to deliver Akuvox action', err);
    }
  };

  if (changed) {
    const onLoad = () => {
      frame.removeEventListener('load', onLoad);
      deliver();
    };
    frame.addEventListener('load', onLoad, { once: true });
  } else {
    deliver();
  }
}

async function fetchVersion(){
  const badge = document.getElementById('appVersion');
  const footer = document.getElementById('appFooter');
  const token = getToken();
  const headers = token ? { 'Authorization': 'Bearer ' + token } : {};
  try {
    const res = await fetch(API_STATE, {
      credentials: 'same-origin',
      headers
    });
    if (!res.ok) throw new Error(await res.text());
    const data = await res.json();
    const label = data?.kpis?.version || 'â€”';
    if (badge) badge.textContent = label;
    const raw = data?.kpis?.version_raw || '';
    if (footer) footer.textContent = raw ? `Integration version ${label} (${raw})` : `Integration version ${label}`;
  } catch (err) {
    if (badge) badge.textContent = 'Version unavailable';
    if (footer) footer.textContent = 'Unable to load version information';
  }
}

document.querySelectorAll('nav.nav-buttons .nav-btn').forEach(btn => {
  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    const view = normalizeView(btn.dataset.view);
    const params = paramsFromButton(btn);
    const group = btn.dataset.groupToggle || null;
    if (group) {
      expandedGroup = expandedGroup === group ? null : group;
    } else {
      expandedGroup = null;
    }
    updateGroupExpansion();
    loadView(view, params, { replaceState: false });
  });
});

document.querySelectorAll('.mobile-launcher [data-view], .mobile-launcher [data-group-toggle]').forEach(btn => {
  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    const rawView = btn.dataset.view || '';
    const hasView = rawView.trim() !== '';
    const view = hasView ? normalizeView(rawView) : null;
    const params = hasView ? paramsFromButton(btn) : {};
    const isSubAction = !!btn.closest('.mobile-subgrid');
    const toggleGroup = btn.dataset.groupToggle || null;
    const parentGroup = btn.closest('[data-group]')?.dataset.group || null;

    if (toggleGroup) {
      const wasExpanded = expandedGroup === toggleGroup;
      expandedGroup = wasExpanded ? null : toggleGroup;
      updateGroupExpansion();
      if (isMobileMode && !isSubAction) {
        if (!hasView) return;
        if (!wasExpanded) return;
      }
      if (!hasView && !isSubAction) return;
    } else if (isSubAction && parentGroup) {
      expandedGroup = parentGroup;
      updateGroupExpansion();
    }
    if (!hasView) return;
    if (isMobileMode) setMobileStage('content');
    loadView(view, params, { replaceState: false });
  });
});

document.querySelectorAll('#navQuickActions [data-view]').forEach(btn => {
  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    const view = normalizeView(btn.dataset.view);
    const params = paramsFromButton(btn);
    const group = btn.closest('[data-group]')?.dataset.group || null;
    if (group) expandedGroup = expandedGroup === group ? null : group;
    updateGroupExpansion();
    if (isMobileMode) setMobileStage('content', { preserveGroups: true });
    loadView(view, params, { replaceState: false });
  });
});

document.querySelectorAll('#navQuickActions [data-action], .mobile-launcher [data-action]').forEach(btn => {
  btn.addEventListener('click', (ev) => {
    ev.preventDefault();
    const action = (btn.dataset.action || '').toLowerCase();
    if (!action) return;
    const group = btn.closest('[data-group]')?.dataset.group || null;
    if (group) expandedGroup = group;
    updateGroupExpansion();
    runDashboardAction(action);
    if (isMobileMode) setMobileStage('content', { preserveGroups: true });
  });
});

const mobileBackBtn = document.getElementById('mobileBackBtn');
if (mobileBackBtn) {
  mobileBackBtn.addEventListener('click', (ev) => {
    ev.preventDefault();
    if (!isMobileMode) return;
    setMobileStage('nav');
  });
}

updateGroupExpansion();

window.addEventListener('message', (event) => {
  if (event.origin !== window.location.origin) return;
  const data = event.data || {};
  if (data.type !== 'akuvox-nav') return;
  const view = normalizeView(data.view || data.slug || data.target || DEFAULT_VIEW);
  const params = data.params || {};
  const opts = {
    updateHistory: data.updateHistory !== false,
    replaceState: !!data.replaceState
  };
  loadView(view, params, opts);
});

window.addEventListener('popstate', (event) => {
  const state = event.state || {};
  const view = normalizeView(state.view || new URLSearchParams(location.search).get('view') || DEFAULT_VIEW);
  const params = state.params || paramsFromSearch(location.search);
  if (isMobileMode) {
    const targetStage = state.mobileStage || 'content';
    setMobileStage(targetStage, { preserveGroups: true });
  }
  loadView(view, params, { updateHistory: false });
});

(function init(){
  const searchParams = new URLSearchParams(location.search);
  const initialView = normalizeView(searchParams.get('view') || DEFAULT_VIEW);
  const params = paramsFromSearch(location.search);
  loadView(initialView, params, { replaceState: true });
  fetchVersion();
})();
</script>
</body>
</html>
