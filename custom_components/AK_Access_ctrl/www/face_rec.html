<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox Face Enrolment</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />
  <style>
    :root{ --bg:#0b1320; --card:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc; }
    body{ background:var(--bg); color:var(--text); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .card{ background:#111a2b; border:1px solid #1b2942; }
    .muted{ color:var(--muted); }
    video, canvas{ width:100%; max-width: 420px; border-radius: .5rem; }
    .btn-row{ gap:.5rem; flex-wrap:wrap; }
  </style>
</head>
<body>
<script>
/* ---------- Auth + helpers ---------- */
(function () {
  const qs = new URLSearchParams(location.search);
  const qsToken = qs.get('token');
  if (qsToken) sessionStorage.setItem('akuvox_ll_token', qsToken);
})();
function findHaToken(){ const t = sessionStorage.getItem('akuvox_ll_token'); return t || null; }
const SAME_ORIGIN = { credentials: 'same-origin' };
const REJECTED_TOKENS = new Set();

function nextBearerToken(){
  const token = findHaToken();
  if (!token) return null;
  if (REJECTED_TOKENS.has(token)) return null;
  return token;
}

async function fetchWithAuth(url, options = {}, { allowRetry = true } = {}){
  const originalHeaders = { ...(options.headers || {}) };
  let bearer = allowRetry ? nextBearerToken() : null;
  let usedBearer = !!bearer;
  const headers = { ...originalHeaders };
  if (bearer) headers['Authorization'] = 'Bearer ' + bearer;

  const response = await fetch(url, { ...SAME_ORIGIN, ...options, headers });

  if (allowRetry && usedBearer && (response.status === 401 || response.status === 403)){
    REJECTED_TOKENS.add(bearer);
    const retryToken = nextBearerToken();
    if (retryToken && retryToken !== bearer){
      return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: true });
    }
    return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: false });
  }

  return response;
}

function buildError(res, text){
  const message = `${res.status}: ${text || res.statusText || 'Request failed'}`;
  const err = new Error(message);
  err.status = res.status;
  err.body = text;
  return err;
}

function isAuthError(err){
  if (!err) return false;
  if (err.status === 401 || err.status === 403) return true;
  const msg = String(err.message || err || '').toLowerCase();
  return msg.includes('401') || msg.includes('403') || msg.includes('unauthor');
}

function redirectToUnauthorized(){
  try {
    const path = (window.location.pathname || '').toLowerCase();
    if (path.endsWith('/unauthorized') || path.endsWith('/unauthorized.html')) {
      return true;
    }
  } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'akuvox-nav', view: 'unauthorized', slug: 'unauthorized', params: {} }, window.location.origin);
    }
  } catch (err) {}

  let href = '/akuvox-ac/unauthorized';
  try {
    const token = sessionStorage.getItem('akuvox_ll_token');
    if (token) {
      const search = new URLSearchParams();
      search.set('token', token);
      href = `/akuvox-ac/unauthorized?${search.toString()}`;
    }
  } catch (err) {}

  try { window.location.replace(href); }
  catch (err) { window.location.href = href; }
  return true;
}

function handleAuthError(err){
  if (!isAuthError(err)) return false;
  redirectToUnauthorized();
  return true;
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_UPLOAD_FACE = signedPath('upload_face', '/api/akuvox_ac/ui/upload_face');

function qsGet(k){ return new URLSearchParams(location.search).get(k) || ''; }
const USER_ID = qsGet('user');      // e.g. HA001
const DEVICE_ID = qsGet('device');  // informational for now

function setBusy(yes){
  document.getElementById('busy').style.display = yes ? 'inline-block' : 'none';
}
function setStatus(msg, good=false){
  const el = document.getElementById('status');
  el.textContent = msg || '';
  el.className = good ? 'text-success' : 'text-warning';
}

/* ---------- Camera capture ---------- */
let mediaStream = null;
let usingFront = true;

async function startCamera(){
  setStatus('');
  try{
    if (mediaStream){
      mediaStream.getTracks().forEach(t=>t.stop());
      mediaStream = null;
    }
    const constraints = {
      video: {
        facingMode: usingFront ? 'user' : 'environment',
        width: { ideal: 1280 },
        height: { ideal: 720 }
      },
      audio: false
    };
    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    const v = document.getElementById('video');
    v.srcObject = mediaStream;
    await v.play();
    document.getElementById('shot').disabled = false;
    document.getElementById('switch').disabled = false;
  }catch(e){
    setStatus('Camera unavailable. Use file upload below instead.');
    document.getElementById('shot').disabled = true;
    document.getElementById('switch').disabled = true;
  }
}

function switchCamera(){
  usingFront = !usingFront;
  startCamera();
}

function snapToCanvas(){
  const v = document.getElementById('video');
  const c = document.getElementById('canvas');
  const w = v.videoWidth || 1280, h = v.videoHeight || 720;
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  ctx.drawImage(v, 0, 0, w, h);
  document.getElementById('uploadCanvas').disabled = false;
}

/* ---------- Upload helpers ---------- */
async function uploadBlobAsJpg(blob){
  if (!USER_ID || !/^HA\d{3}$/.test(USER_ID)){
    setStatus('Missing or invalid user id. This page must be opened with ?user=HAxxx.', false);
    return;
  }
  const fd = new FormData();
  fd.append('id', USER_ID);
  fd.append('file', blob, USER_ID + '.jpg');

  setBusy(true);
  try{
    const r = await fetchWithAuth(API_UPLOAD_FACE, {
      method:'POST',
      body: fd
    });
    const text = await r.text();
    let res = {};
    try { res = JSON.parse(text); } catch { res = { ok: r.ok, raw: text }; }
    if (!r.ok || res.ok === false){
      const err = res && res.error ? new Error(res.error) : buildError(r, text);
      handleAuthError(err);
      if (res && res.error) err.message = res.error;
      setStatus('Upload failed: ' + (res.error || text || err.message || r.status), false);
      return;
    }
    setStatus('Face uploaded. A sync will push it to the device shortly.', true);
  }catch(e){
    if (handleAuthError(e)) return;
    setStatus('Upload error: ' + (e && e.message ? e.message : e), false);
  }finally{
    setBusy(false);
  }
}

async function uploadFromCanvas(){
  const c = document.getElementById('canvas');
  if (!c.width || !c.height){
    setStatus('Take a snapshot first.', false);
    return;
  }
  c.toBlob(async (blob)=> {
    if (!blob){ setStatus('Snapshot encode failed.', false); return; }
    await uploadBlobAsJpg(blob);
  }, 'image/jpeg', 0.92);
}

async function uploadFromFile(){
  const inp = document.getElementById('file');
  if (!inp.files || !inp.files[0]){
    setStatus('Choose a JPG file first.', false);
    return;
  }
  const f = inp.files[0];
  if (!/jpe?g$/i.test(f.name) && f.type !== 'image/jpeg'){
    setStatus('Please select a JPG file.', false);
    return;
  }
  await uploadBlobAsJpg(f);
}

/* ---------- init ---------- */
document.addEventListener('DOMContentLoaded', ()=>{
  document.getElementById('userBadge').textContent = USER_ID || '(unknown)';
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
    startCamera();
  }else{
    setStatus('Camera API not supported. Use file upload instead.');
  }
});
</script>

<div class="container py-3">
  <div class="d-flex align-items-center gap-2 mb-2">
    <h3 class="m-0">Face Enrolment</h3>
    <span id="busy" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display:none;"></span>
  </div>

  <div class="card p-3 mb-3">
    <div class="mb-2"><span class="muted">User:</span> <span id="userBadge" class="badge bg-secondary"></span></div>

    <!-- Camera capture -->
    <div class="row g-3 align-items-start">
      <div class="col-md-6">
        <video id="video" playsinline muted></video>
        <div class="d-flex btn-row mt-2">
          <button id="shot" class="btn btn-primary" onclick="snapToCanvas()">Take snapshot</button>
          <button id="switch" class="btn btn-outline-light" onclick="switchCamera()">Switch camera</button>
        </div>
      </div>
      <div class="col-md-6">
        <canvas id="canvas"></canvas>
        <div class="d-flex btn-row mt-2">
          <button id="uploadCanvas" class="btn btn-success" onclick="uploadFromCanvas()" disabled>Upload snapshot</button>
        </div>
      </div>
    </div>
  </div>

  <!-- File upload fallback -->
  <div class="card p-3">
    <div class="mb-2 muted">No camera? Upload a JPG instead:</div>
    <div class="d-flex btn-row align-items-center">
      <input id="file" type="file" accept=".jpg,image/jpeg" class="form-control" style="max-width:420px;" />
      <button class="btn btn-success" onclick="uploadFromFile()">Upload selected file</button>
    </div>
  </div>

  <div class="mt-3" id="status"></div>
</div>
</body>
</html>
