<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox User Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
  <style>
    :root{ --bg:#0b1320; --card:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc; }
    body{ background:var(--bg); color:var(--text); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .container-narrow{ max-width:960px; margin:0 auto; }
    .card{ background:#111a2b; border:1px solid #1b2942; }
    .card + .card{ margin-top:1.5rem; }
    label{ color:#fff; }
    .muted{ color:var(--muted); }
    .btn-toggle{ width: 220px; }
    .uploader-hint { font-size: .9rem; color: var(--muted); }
    .form-text code { color: #c7dfff; }
    .face-options{ display:flex; gap:0.5rem; flex-wrap:wrap; }
    .face-preview-frame{ width:160px; height:160px; border:1px dashed var(--border); border-radius:0.5rem; background:#0f1726; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .face-preview-frame img{ max-width:100%; max-height:100%; object-fit:cover; display:none; }
    .face-preview-placeholder{ font-size:0.8rem; color:var(--muted); text-align:center; padding:0.5rem; }
    .action-buttons{ display:flex; gap:0.5rem; flex-wrap:wrap; }
    .license-plate-row .btn{ min-width:3rem; }
    .license-plate-input{text-transform:uppercase; }
    @media (max-width: 992px){
      .container-narrow{ max-width:100%; }
    }
    @media (max-width: 720px){
      .container-narrow{ padding:0.75rem; }
      .card{ padding:1.25rem; }
      .btn-toggle{ width:100%; }
      .face-options{ flex-direction:column; }
      .action-buttons{ flex-direction:column; }
      .action-buttons .btn, .action-buttons a{ width:100%; }
    }
  </style>
</head>
<body>
<script>
/* -------------------- auth + helpers -------------------- */
(function () {
  const qs = new URLSearchParams(location.search);
  const qsToken = qs.get('token');
  if (qsToken) persistTokens(qsToken);
})();
function persistTokens(access, refresh) {
  if (!access) return null;
  const payload = { access_token: access };
  if (refresh) payload.refresh_token = refresh;
  const serialized = JSON.stringify(payload);
  try { sessionStorage.setItem('akuvox_ll_token', access); } catch (err) {}
  try { localStorage.setItem('akuvox_ll_token', access); } catch (err) {}
  try { sessionStorage.setItem('akuvox_hassTokens', serialized); } catch (err) {}
  try { localStorage.setItem('akuvox_hassTokens', serialized); } catch (err) {}
  try { window.AK_AC_HASS_TOKEN = access; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      try { window.parent.sessionStorage.setItem('akuvox_ll_token', access); } catch (err2) {}
      try { window.parent.localStorage.setItem('akuvox_ll_token', access); } catch (err2) {}
      try { window.parent.sessionStorage.setItem('akuvox_hassTokens', serialized); } catch (err2) {}
      try { window.parent.localStorage.setItem('akuvox_hassTokens', serialized); } catch (err2) {}
      try { window.parent.AK_AC_HASS_TOKEN = access; } catch (err2) {}
    }
  } catch (err) {}
  return access;
}

function extractTokenFromAuth(auth) {
  if (!auth || typeof auth !== 'object') return null;
  const access = auth.accessToken
    || auth.access_token
    || auth?.token?.access_token
    || auth?.data?.access_token
    || null;
  const refresh = auth.refreshToken
    || auth.refresh_token
    || auth?.token?.refresh_token
    || auth?.data?.refresh_token
    || null;
  if (access) {
    return persistTokens(access, refresh);
  }
  return null;
}

function scanTokenStorage(storage) {
  if (!storage) return null;
  try {
    const raw = storage.getItem('hassTokens');
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {
        if (typeof raw === 'string' && raw.trim()) {
          return persistTokens(raw.trim());
        }
      }
    }
    for (const key of Object.keys(storage)) {
      if (!/auth|token|hass/i.test(key)) continue;
      try {
        const parsed = JSON.parse(storage.getItem(key));
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {}
    }
  } catch (err) {}
  return null;
}

function tokenFromWindow(win) {
  if (!win) return null;
  let token = null;
  token = scanTokenStorage(win.sessionStorage) || scanTokenStorage(win.localStorage);
  if (token) return token;

  token = extractTokenFromAuth(win.hassAuth)
    || extractTokenFromAuth(win.auth)
    || extractTokenFromAuth(win.AK_AC_HA_AUTH)
    || null;
  if (token) return token;

  try {
    const conn = win.hassConnection;
    if (conn && typeof conn.then === 'function') {
      conn.then((resolved) => {
        try {
          extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
        } catch (err) {}
      }).catch(() => {});
    } else if (conn) {
      token = extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      if (token) return token;
    }
  } catch (err) {}

  return null;
}

const FACE_UPLOAD_MAX_BYTES = 2 * 1024 * 1024;
const FACE_UPLOAD_ALLOWED_TYPES = ['image/jpeg', 'image/png'];
const FACE_UPLOAD_ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png'];
const FACE_UPLOAD_MAX_DIMENSION = 1280;
const FACE_UPLOAD_MIN_DIMENSION = 480;
const FACE_DATA_PATH = '/api/AK_AC/FaceData';

let facePreviewUrl = null;
let facePreviewMode = 'none';

function isImageFile(file) {
  return !!file && typeof file.type === 'string' && file.type.startsWith('image/');
}

function replaceFileExtension(name, nextExt) {
  const base = name ? name.replace(/\.[^/.]+$/, '') : 'face-photo';
  return `${base}${nextExt}`;
}

function loadImageFromFile(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const objectUrl = URL.createObjectURL(file);
    img.onload = () => {
      URL.revokeObjectURL(objectUrl);
      resolve(img);
    };
    img.onerror = () => {
      URL.revokeObjectURL(objectUrl);
      reject(new Error('Unable to read image file.'));
    };
    img.src = objectUrl;
  });
}

function encodeImageToJpeg(img, targetDim, quality) {
  const scale = Math.min(1, targetDim / Math.max(img.width, img.height));
  const width = Math.max(1, Math.round(img.width * scale));
  const height = Math.max(1, Math.round(img.height * scale));
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, width, height);
  return new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', quality));
}

async function prepareFaceFile(file) {
  if (!file) return null;
  const name = (file.name || '').toLowerCase();
  const hasAllowedExtension = FACE_UPLOAD_ALLOWED_EXTENSIONS.some((ext) => name.endsWith(ext));
  const allowedType = FACE_UPLOAD_ALLOWED_TYPES.includes(file.type) || hasAllowedExtension;
  if (!isImageFile(file)) {
    throw new Error('Face photo must be an image file.');
  }

  if (file.size <= FACE_UPLOAD_MAX_BYTES && allowedType) {
    return file;
  }

  const img = await loadImageFromFile(file);
  let targetDim = Math.min(FACE_UPLOAD_MAX_DIMENSION, Math.max(img.width, img.height));
  let quality = 0.9;
  let blob = await encodeImageToJpeg(img, targetDim, quality);

  while (blob && blob.size > FACE_UPLOAD_MAX_BYTES && (quality > 0.6 || targetDim > FACE_UPLOAD_MIN_DIMENSION)) {
    if (quality > 0.6) {
      quality = Math.max(0.6, quality - 0.1);
    } else {
      targetDim = Math.max(FACE_UPLOAD_MIN_DIMENSION, Math.round(targetDim * 0.85));
    }
    blob = await encodeImageToJpeg(img, targetDim, quality);
  }

  if (!blob) {
    throw new Error('Unable to process the selected face photo.');
  }
  if (blob.size > FACE_UPLOAD_MAX_BYTES) {
    throw new Error('Face photo could not be reduced below 2MB.');
  }

  return new File([blob], replaceFileExtension(file.name, '.jpg'), { type: 'image/jpeg' });
}

function setFacePreview(file) {
  const preview = document.getElementById('facePreview');
  const placeholder = document.getElementById('facePreviewPlaceholder');
  if (!preview) return;
  if (facePreviewUrl) {
    URL.revokeObjectURL(facePreviewUrl);
    facePreviewUrl = null;
  }
  if (!file) {
    preview.src = '';
    preview.style.display = 'none';
    if (placeholder) placeholder.style.display = 'block';
    facePreviewMode = 'none';
    return;
  }
  facePreviewUrl = URL.createObjectURL(file);
  preview.src = facePreviewUrl;
  preview.style.display = 'block';
  if (placeholder) placeholder.style.display = 'none';
  facePreviewMode = 'file';
}

function buildFacePreviewUrl(url) {
  const text = String(url || '').trim();
  if (!text) return '';
  const stamp = `t=${Date.now()}`;
  return text.includes('?') ? `${text}&${stamp}` : `${text}?${stamp}`;
}

function setFacePreviewUrl(url) {
  const preview = document.getElementById('facePreview');
  const placeholder = document.getElementById('facePreviewPlaceholder');
  if (!preview) return;
  if (facePreviewUrl) {
    URL.revokeObjectURL(facePreviewUrl);
    facePreviewUrl = null;
  }
  const finalUrl = buildFacePreviewUrl(url);
  if (!finalUrl) {
    setFacePreview(null);
    return;
  }
  preview.src = finalUrl;
  preview.style.display = 'block';
  if (placeholder) placeholder.style.display = 'none';
  facePreviewMode = 'remote';
}

function hasExistingFace() {
  if (!CURRENT || CURRENT.face_removed) return false;
  const faceUrl = String(CURRENT.face_url || '').trim();
  if (faceUrl) return true;
  const status = String(CURRENT.face_status || '').trim().toLowerCase();
  return !!CURRENT.face_active || status === 'active' || status === 'pending';
}

function facePreviewUrlFromCurrent() {
  if (!CURRENT) return '';
  const faceUrl = String(CURRENT.face_url || '').trim();
  if (faceUrl) return faceUrl;
  if (CURRENT.id) return `${FACE_DATA_PATH}/${CURRENT.id}.jpg`;
  return '';
}

function updateFacePreviewState() {
  const placeholder = document.getElementById('facePreviewPlaceholder');
  const fileInput = document.getElementById('facefile');
  const hasFile = !!(fileInput && fileInput.files && fileInput.files[0]);
  if (hasFile) {
    if (placeholder) placeholder.textContent = 'Selected photo preview';
    updateRemoveFaceButton();
    return;
  }
  if (hasExistingFace()) {
    setFacePreviewUrl(facePreviewUrlFromCurrent());
    if (placeholder) placeholder.textContent = 'Current photo on file';
  } else {
    setFacePreview(null);
    if (placeholder) placeholder.textContent = 'No photo on file';
  }
  updateRemoveFaceButton();
}

function updateRemoveFaceButton() {
  const btn = document.getElementById('removeFaceBtn');
  if (!btn) return;
  const canRemove = !!(CURRENT && CURRENT.id && hasExistingFace());
  btn.style.display = canRemove ? '' : 'none';
  btn.disabled = !canRemove || BUSY;
}

function bindFaceFileInput() {
  const input = document.getElementById('facefile');
  if (!input || input._faceBound) return;
  input.addEventListener('change', async () => {
    if (!input.files || !input.files[0]) {
      input._processedFace = null;
      input._processedToken = null;
      updateFacePreviewState();
      return;
    }
    const file = input.files[0];
    const token = `${file.name}:${file.size}:${file.lastModified}`;
    try {
      const processed = await prepareFaceFile(file);
      input._processedFace = processed;
      input._processedToken = token;
      setFacePreview(processed);
      updateRemoveFaceButton();
    } catch (err) {
      input.value = '';
      input._processedFace = null;
      input._processedToken = null;
      setFacePreview(null);
      updateFacePreviewState();
      alert(err && err.message ? err.message : err);
    }
  });
  input._faceBound = true;
}

function walkAuthWindows(start) {
  const visited = new Set();
  let current = start;
  while (current && !visited.has(current)) {
    const token = tokenFromWindow(current);
    if (token) return token;
    visited.add(current);

    let next = null;
    try {
      next = current.parent;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    try {
      next = current.opener;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    break;
  }
  return null;
}

(function bootstrapAuthWatchers() {
  const seen = new WeakSet();
  function attach(win) {
    if (!win || seen.has(win)) return;
    seen.add(win);
    try { extractTokenFromAuth(win.hassAuth || win.auth || win.AK_AC_HA_AUTH); } catch (err) {}
    try {
      const conn = win.hassConnection;
      if (conn && typeof conn.then === 'function') {
        conn.then((resolved) => {
          try {
            extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
          } catch (err) {}
        }).catch(() => {});
      } else if (conn) {
        extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      }
    } catch (err) {}
    try {
      if (win.parent && win.parent !== win) attach(win.parent);
    } catch (err) {}
    try {
      if (win.opener) attach(win.opener);
    } catch (err) {}
  }
  attach(window);
})();

function findHaToken(){
  const existing = sessionStorage.getItem('akuvox_ll_token');
  if (existing) return existing;
  const token = walkAuthWindows(window);
  if (token) {
    try { sessionStorage.setItem('akuvox_ll_token', token); } catch (err) {}
  }
  return token;
}
const SAME_ORIGIN = { credentials: 'same-origin' };
const REJECTED_TOKENS = new Set();

const AUTH_SIG_KEY = 'akuvox_auth_sig';

function readAuthSigFrom(search = location.search){
  try {
    const params = new URLSearchParams(search);
    const value = params.get('authSig');
    return value || '';
  } catch (err) {
    return '';
  }
}

function rememberAuthSig(value){
  if (!value) return;
  try { sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { window.AK_AC_AUTH_SIG = value; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      const parent = window.parent;
      try { parent.sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.AK_AC_AUTH_SIG = value; } catch (err) {}
    }
  } catch (err) {}
}

function currentAuthSig(){
  const fromUrl = readAuthSigFrom();
  if (fromUrl) {
    rememberAuthSig(fromUrl);
    return fromUrl;
  }

  const sources = [
    () => {
      try { return sessionStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return localStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return window.AK_AC_AUTH_SIG || null; } catch (err) { return null; }
    },
    () => {
      try {
        if (window.parent && window.parent !== window) {
          const parent = window.parent;
          return parent.AK_AC_AUTH_SIG
            || (parent.sessionStorage && parent.sessionStorage.getItem(AUTH_SIG_KEY))
            || (parent.localStorage && parent.localStorage.getItem(AUTH_SIG_KEY));
        }
      } catch (err) {}
      return null;
    }
  ];

  for (const getter of sources) {
    const value = getter();
    if (value) {
      rememberAuthSig(value);
      return value;
    }
  }

  return '';
}

rememberAuthSig(readAuthSigFrom());

function nextBearerToken(){
  const token = findHaToken();
  if (!token) return null;
  if (REJECTED_TOKENS.has(token)) return null;
  return token;
}

async function fetchWithAuth(url, options = {}, { allowRetry = true } = {}){
  const originalHeaders = { ...(options.headers || {}) };
  let bearer = allowRetry ? nextBearerToken() : null;
  let usedBearer = !!bearer;
  const headers = { ...originalHeaders };
  if (bearer) headers['Authorization'] = 'Bearer ' + bearer;

  const response = await fetch(url, { ...SAME_ORIGIN, ...options, headers });

  if (allowRetry && usedBearer && (response.status === 401 || response.status === 403)){
    REJECTED_TOKENS.add(bearer);
    const retryToken = nextBearerToken();
    if (retryToken && retryToken !== bearer){
      return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: true });
    }
    return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: false });
  }

  return response;
}

function buildError(res, text){
  const message = `${res.status}: ${text || res.statusText || 'Request failed'}`;
  const err = new Error(message);
  err.status = res.status;
  err.body = text;
  return err;
}

function isAuthError(err){
  if (!err) return false;
  if (err.status === 401 || err.status === 403) return true;
  const msg = String(err.message || err || '').toLowerCase();
  return msg.includes('401') || msg.includes('403') || msg.includes('unauthor');
}

function redirectToUnauthorized(params = {}){
  try {
    const path = (window.location.pathname || '').toLowerCase();
    if (path.endsWith('/unauthorized') || path.endsWith('/unauthorized.html')) {
      return true;
    }
  } catch (err) {}

  const targetParams = params && typeof params === 'object' ? params : {};
  let href = '/akuvox-ac/unauthorized';
  try {
    href = buildHref('unauthorized', targetParams);
  } catch (err) {
    try {
      const search = new URLSearchParams();
      Object.entries(targetParams).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== '') search.set(key, value);
      });
      const token = sessionStorage.getItem('akuvox_ll_token');
      if (token && !search.has('token')) search.set('token', token);
      const authSig = currentAuthSig();
      if (authSig && !search.has('authSig')) search.set('authSig', authSig);
      const query = search.toString();
      if (query) href = `/akuvox-ac/unauthorized?${query}`;
    } catch (err2) {}
  }

  let delivered = false;
  try {
    delivered = requestParentNav('unauthorized', targetParams, { replaceState: true });
  } catch (err) {}

  if (!delivered) {
    try { window.location.replace(href); }
    catch (err) { window.location.href = href; }
  }
  return true;
}

function handleAuthError(err){
  if (!isAuthError(err)) return false;
  redirectToUnauthorized();
  return true;
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_STATE           = signedPath('state', '/api/akuvox_ac/ui/state');
const API_PHONES          = signedPath('phones', '/api/akuvox_ac/ui/phones');
const API_RESERVE_ID      = signedPath('reserve_id', '/api/akuvox_ac/ui/reserve_id');
const API_RELEASE_ID      = signedPath('release_id', '/api/akuvox_ac/ui/release_id');
const API_RESERVATION_PING = signedPath('reservation_ping', '/api/akuvox_ac/ui/reservation_ping');
const API_UPLOAD_FACE     = signedPath('upload_face', '/api/akuvox_ac/ui/upload_face');
const API_REMOTE_ENROL    = signedPath('remote_enrol', '/api/akuvox_ac/ui/remote_enrol');
const API_ACTION          = signedPath('action', '/api/akuvox_ac/ui/action');
const API_EDIT_USER       = signedPath('service_edit_user', '/api/services/akuvox_ac/edit_user');

const DEFAULT_CREDENTIAL_PROMPTS = { code: true, token: true, anpr: false, face: true, phone: true };
let CREDENTIAL_PROMPTS = { ...DEFAULT_CREDENTIAL_PROMPTS };
const MAX_LICENSE_PLATES = 5;

async function apiGet(url){
  const r = await fetchWithAuth(url);
  if (!r.ok){
    const text = await r.text();
    const err = buildError(r, text);
    handleAuthError(err);
    throw err;
  }
  return r.json();
}
async function apiPost(url, body){
  const r = await fetchWithAuth(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body||{}) });
  if (!r.ok){
    const text = await r.text();
    const err = buildError(r, text);
    handleAuthError(err);
    throw err;
  }
  return r.json();
}
const UI_ROOT = '/akuvox-ac';
const PAUSED_USERS_KEY = 'akuvox_paused_users';
let BUSY = false;

function loadPausedUsers(){
  try {
    const raw = sessionStorage.getItem(PAUSED_USERS_KEY) || localStorage.getItem(PAUSED_USERS_KEY);
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') return parsed;
  } catch (err) {}
  return {};
}

let PAUSED_USERS = loadPausedUsers();

function pausedScheduleInfo(userId){
  const stored = userId && PAUSED_USERS ? PAUSED_USERS[userId] : null;
  if (stored && typeof stored === 'object') {
    const scheduleId = String(stored.schedule_id || '').trim();
    const scheduleName = String(stored.schedule_name || '').trim();
    if (scheduleId || scheduleName) {
      return { schedule_id: scheduleId, schedule_name: scheduleName };
    }
  }
  if (typeof stored === 'string' && stored.trim()) {
    const match = stored.match(/^(\d+)/);
    if (match) {
      return { schedule_id: match[1], schedule_name: '' };
    }
  }
  return null;
}

function applyPausedScheduleToCurrent(){
  if (!CURRENT || !CURRENT.id) return;
  const info = pausedScheduleInfo(CURRENT.id);
  if (!info) return;
  if (info.schedule_id) CURRENT.schedule_id = info.schedule_id;
  if (info.schedule_name) {
    CURRENT.schedule_name = info.schedule_name;
  } else if (info.schedule_id) {
    CURRENT.schedule_name = nameForId(info.schedule_id);
  }
}
function setBusy(yes){
  BUSY = !!yes;
  const busyEl = document.getElementById('busy');
  if (busyEl) busyEl.style.display = yes ? 'inline-block':'none';
  document.querySelectorAll('[data-busy-lock]').forEach(el => {
    if (yes){
      if (!el.dataset.busyPrevDisabled){
        el.dataset.busyPrevDisabled = el.disabled ? '1' : '0';
      }
      if ('disabled' in el) el.disabled = true;
    } else if (el.dataset.busyPrevDisabled) {
      if ('disabled' in el) el.disabled = el.dataset.busyPrevDisabled === '1';
      delete el.dataset.busyPrevDisabled;
    }
  });
  updateRemoveFaceButton();
}

function buildHref(slug, params = {}) {
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === undefined || value === null || value === '') return;
    search.set(key, value);
  });
  const token = sessionStorage.getItem('akuvox_ll_token');
  if (token) search.set('token', token);
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const clean = String(slug || '').replace(/_/g, '-');
  return `${UI_ROOT}/${clean}${query ? `?${query}` : ''}`;
}

function requestParentNav(view, params = {}, options = {}) {
  try {
    if (window.parent && window.parent !== window) {
      try {
        const parentDoc = window.parent.document;
        if (!parentDoc || !parentDoc.getElementById('viewFrame')) return false;
      } catch (err) {
        return false;
      }
      const msg = {
        type: 'akuvox-nav',
        view: String(view || ''),
        slug: String(view || ''),
        params
      };
      if (options.updateHistory === false) msg.updateHistory = false;
      if (options.replaceState) msg.replaceState = true;
      window.parent.postMessage(msg, window.location.origin);
      return true;
    }
  } catch (err) {}
  return false;
}

function openInApp(view, params = {}, options = {}) {
  const href = buildHref(view, params);
  const delivered = requestParentNav(view, params, options);
  if (!delivered) {
    window.location.href = href;
  }
  return delivered;
}

/* -------------------- app state -------------------- */
let SCHEDULES = {};     // { name: weekSpec, ... }
let SCHEDULE_IDS = {};  // { name: scheduleId, ... }
let EXIT_CLONES = {};   // { normalizedName: cloneName }
let scheduleRefreshPromise = null;
let scheduleRefreshTimer = null;
let PHONES = [];        // [{service, name}, ...] from /api/akuvox_ac/ui/phones
let REGISTRY = [];      // UI list of known users from /ui/state
let DEVICES = [];       // [{entry_id, name, users}, ...] from /ui/state
let CURRENT = null;     // working user object
let RESERVED_ID = null; // HA### id reserved for new-user workflow
let ANY_ALARM_CAPABLE = true;

let reservationTimer = null;
let reservationMisses = 0;
let reservationHeartbeatBusy = false;

const RESERVATION_STORAGE_KEY = 'akuvox_ac_reserved_id';
const RESERVATION_STALE_AFTER = 15 * 60 * 1000; // 15 minutes

function parseReservationRecord(raw) {
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    const id = String(parsed.id || '').trim();
    if (!id) return null;
    const ts = Number(parsed.ts || 0);
    return { id, ts: Number.isFinite(ts) && ts > 0 ? ts : Date.now() };
  } catch (err) {
    return null;
  }
}

function rememberReservationId(id) {
  const clean = String(id || '').trim();
  if (!clean) {
    forgetReservationId();
    return;
  }
  try {
    if (typeof sessionStorage !== 'undefined') {
      sessionStorage.setItem(RESERVATION_STORAGE_KEY, JSON.stringify({ id: clean, ts: Date.now() }));
    }
  } catch (err) {}
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(RESERVATION_STORAGE_KEY, JSON.stringify({ id: clean, ts: Date.now() }));
    }
  } catch (err) {}
}

function forgetReservationId() {
  try {
    if (typeof sessionStorage !== 'undefined') {
      sessionStorage.removeItem(RESERVATION_STORAGE_KEY);
    }
  } catch (err) {}
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.removeItem(RESERVATION_STORAGE_KEY);
    }
  } catch (err) {}
}

function readStoredReservation() {
  const fromSession = (() => {
    try {
      if (typeof sessionStorage === 'undefined') return null;
      return parseReservationRecord(sessionStorage.getItem(RESERVATION_STORAGE_KEY));
    } catch (err) {
      return null;
    }
  })();
  if (fromSession) return fromSession;

  const fromLocal = (() => {
    try {
      if (typeof localStorage === 'undefined') return null;
      return parseReservationRecord(localStorage.getItem(RESERVATION_STORAGE_KEY));
    } catch (err) {
      return null;
    }
  })();
  if (!fromLocal) return null;

  try {
    if (typeof sessionStorage !== 'undefined') {
      const payload = JSON.stringify({ id: fromLocal.id, ts: fromLocal.ts || Date.now() });
      sessionStorage.setItem(RESERVATION_STORAGE_KEY, payload);
    }
  } catch (err) {}
  try {
    if (typeof localStorage !== 'undefined') {
      const payload = JSON.stringify({ id: fromLocal.id, ts: fromLocal.ts || Date.now() });
      localStorage.setItem(RESERVATION_STORAGE_KEY, payload);
    }
  } catch (err) {
    /* ignore */
  }
  return fromLocal;
}

function setReservationMessage(html, tone = 'muted') {
  const el = document.getElementById('localHelp');
  if (!el) return;
  if (!html) {
    el.innerHTML = '';
    return;
  }
  const cls = tone === 'error' ? 'text-danger' : tone === 'warning' ? 'text-warning' : 'muted';
  el.innerHTML = `<span class="${cls}">${html}</span>`;
}

function escapeHtml(value){
  return String(value ?? '').replace(/[&<>"']/g, (ch) => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  }[ch] || ch));
}

function normalizedUserKey(value){
  return String(value ?? '').trim().toLowerCase();
}

function isRegistryUser(userId){
  const key = normalizedUserKey(userId);
  if (!key) return false;
  return (REGISTRY || []).some((entry) => {
    if (!entry || typeof entry !== 'object') return false;
    const entryKey = normalizedUserKey(entry.id || entry.UserID || entry.UserId || entry.ID || '');
    return entryKey === key;
  });
}

function deviceUserIdFor(device, userId){
  const target = normalizedUserKey(userId);
  if (!target || !device || typeof device !== 'object') return '';
  const records = Array.isArray(device.users)
    ? device.users
    : Array.isArray(device._users)
    ? device._users
    : [];
  for (const record of records){
    if (!record || typeof record !== 'object') continue;
    const recordKey = normalizedUserKey(record.UserID || record.UserId || record.Name || record.ID || record.id || '');
    if (recordKey && recordKey === target){
      const deviceId = record.ID || record.Id || record.id || '';
      return String(deviceId || '').trim();
    }
  }
  return '';
}

function updateDeviceIdsDisplay(){
  const row = document.getElementById('deviceIdsRow');
  const list = document.getElementById('deviceIdsList');
  if (!row || !list) return;
  const userId = CURRENT && CURRENT.id ? String(CURRENT.id).trim() : '';
  if (!userId || !isRegistryUser(userId)){
    row.style.display = 'none';
    list.innerHTML = '';
    return;
  }
  const devices = Array.isArray(DEVICES) ? DEVICES : [];
  row.style.display = 'block';
  if (!devices.length){
    list.innerHTML = '<div class="muted">No devices available.</div>';
    return;
  }
  list.innerHTML = devices.map((device) => {
    const name = device && typeof device === 'object'
      ? (device.name || device.entry_id || 'Device')
      : 'Device';
    const deviceId = deviceUserIdFor(device, userId);
    return `
      <div class="d-flex justify-content-between align-items-center border-bottom py-1">
        <span>${escapeHtml(name)}</span>
        <span class="text-monospace">${escapeHtml(deviceId || '—')}</span>
      </div>`;
  }).join('');
}

function normalizedScheduleKey(name){
  return String(name || '').trim().toLowerCase();
}

function scheduleCloneSuffix(){
  return ' - EP';
}

function scheduleIsExitClone(name, spec){
  const normalized = normalizedScheduleKey(name);
  if (!normalized) return false;
  const specObj = spec && typeof spec === 'object' ? spec : {};
  if (specObj.system_exit_clone) return true;
  if (specObj.exit_clone_for){
    const base = normalizedScheduleKey(specObj.exit_clone_for);
    if (base && base !== normalized) return true;
  }
  return normalized.endsWith(scheduleCloneSuffix().toLowerCase());
}

function buildExitCloneMap(source){
  const out = {};
  Object.entries(source || {}).forEach(([name, spec]) => {
    const normalized = normalizedScheduleKey(name);
    if (!normalized) return;
    const specObj = spec && typeof spec === 'object' ? spec : {};
    if (scheduleIsExitClone(name, specObj)){
      const base = specObj.exit_clone_for ? String(specObj.exit_clone_for).trim() : name.slice(0, -scheduleCloneSuffix().length);
      const baseNorm = normalizedScheduleKey(base);
      if (baseNorm && baseNorm !== normalized){
        out[baseNorm] = name;
      }
      return;
    }
    const cloneName = specObj.exit_clone_name ? String(specObj.exit_clone_name).trim() : '';
    if (cloneName){
      out[normalized] = cloneName;
    }
  });
  return out;
}

function scheduleHasWorkingExitClone(scheduleName){
  const clone = EXIT_CLONES[normalizedScheduleKey(scheduleName)];
  return !!(clone && SCHEDULES && SCHEDULES[clone]);
}

function applySchedulesUpdate(nextSchedules, nextScheduleIds){
  const scheduleSelect = document.getElementById('schedule');
  const previousId = scheduleSelect ? scheduleSelect.value : (CURRENT && CURRENT.schedule_id ? CURRENT.schedule_id : '');
  const previousName = CURRENT && CURRENT.schedule_name ? CURRENT.schedule_name : '';
  const sanitized = {};
  if (nextSchedules && typeof nextSchedules === 'object'){
    Object.entries(nextSchedules).forEach(([name, spec]) => {
      sanitized[name] = spec;
    });
  }
  SCHEDULES = sanitized;
  const ids = {};
  if (nextScheduleIds && typeof nextScheduleIds === 'object'){
    Object.entries(nextScheduleIds).forEach(([name, value]) => {
      if (!name) return;
      if (value === null || value === undefined) return;
      ids[String(name)] = String(value);
    });
  }
  SCHEDULE_IDS = ids;
  buildScheduleMap();
  if (scheduleSelect){
    const optionsHtml = scheduleOptionsHtml();
    scheduleSelect.innerHTML = optionsHtml;
    const optionIds = new Set(Array.from(scheduleSelect.options).map(opt => opt.value));
    let target = previousId && optionIds.has(previousId) ? previousId : '';
    if (!target && previousName){
      const fallback = idForName(previousName);
      if (optionIds.has(fallback)) target = fallback;
    }
    if (!target){
      target = '1001';
    }
    scheduleSelect.value = target;
    if (CURRENT){
      CURRENT.schedule_id = target;
      CURRENT.schedule_name = nameForId(target);
    }
  }
  ensureExitPermissionAvailability();
}

function queueScheduleRefresh(){
  if (scheduleRefreshTimer){
    return;
  }
  scheduleRefreshTimer = setTimeout(() => {
    scheduleRefreshTimer = null;
    refreshSchedulesFromServer();
  }, 200);
}

async function refreshSchedulesFromServer(){
  if (scheduleRefreshPromise) return scheduleRefreshPromise;
  scheduleRefreshPromise = (async () => {
    try {
      const state = await apiGet(API_STATE);
      if (state && typeof state === 'object' && state.schedules){
        applySchedulesUpdate(state.schedules, state.schedule_ids);
      }
    } catch (err) {
      if (handleAuthError(err)) return;
      console.warn('Failed to refresh schedules', err);
    } finally {
      scheduleRefreshPromise = null;
    }
  })();
  return scheduleRefreshPromise;
}

function handleScheduleRevisionSignal(){
  queueScheduleRefresh();
}

window.addEventListener('storage', (event) => {
  if (!event) return;
  if (event.key === 'akuvox_schedule_revision') {
    handleScheduleRevisionSignal();
  }
});

window.addEventListener('message', (event) => {
  if (!event) return;
  if (event.origin && event.origin !== window.location.origin) return;
  const data = event.data;
  if (data && typeof data === 'object' && data.type === 'akuvox-schedules-updated') {
    handleScheduleRevisionSignal();
  }
});

window.addEventListener('akuvox-schedules-updated', handleScheduleRevisionSignal);

function normalizeExitPermission(value){
  if (value === undefined || value === null) return null;
  if (typeof value === 'boolean') return value ? 'always' : 'match';
  const text = String(value || '').trim().toLowerCase();
  if (!text) return null;
  const cleaned = text.replace(/[-\s]+/g, '_');
  if (['match', 'matching', 'same_as_entry', 'default'].includes(cleaned)) return 'match';
  if (['working_days', 'work_days', 'workingdays', 'workdays'].includes(cleaned)) return 'working_days';
  if (['always', 'always_allow', 'always_permit', 'always_permit_exit', '24_7', '24x7', '1', 'true', 'yes'].includes(cleaned)) return 'always';
  if (['match', 'working_days', 'always'].includes(cleaned)) return cleaned;
  return null;
}

function updateKeyHolderAvailability(){
  const row = document.getElementById('keyHolderRow');
  const input = document.getElementById('key_holder');
  if (!row || !input) return;
  if (ANY_ALARM_CAPABLE){
    row.style.display = '';
  } else {
    row.style.display = 'none';
    input.checked = false;
    if (CURRENT) CURRENT.key_holder = false;
  }
}

function stopReservationHeartbeat() {
  if (reservationTimer) {
    clearInterval(reservationTimer);
    reservationTimer = null;
  }
  reservationHeartbeatBusy = false;
  reservationMisses = 0;
}

async function heartbeatTick() {
  if (!RESERVED_ID || reservationHeartbeatBusy) return;
  reservationHeartbeatBusy = true;
  try {
    const res = await fetchWithAuth(API_RESERVATION_PING, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: RESERVED_ID })
    });
    if (!res.ok) throw new Error(await res.text());
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || 'ping failed');
    if (data.active === false) {
      setReservationMessage('Reserved ID expired. Requesting a new ID…', 'warning');
      RESERVED_ID = null;
      stopReservationHeartbeat();
      const newId = await reserveNewId({ showWarning: true });
      if (newId && CURRENT) CURRENT.id = newId;
      return;
    }
    reservationMisses = 0;
  } catch (err) {
    if (handleAuthError(err)) return;
    reservationMisses += 1;
    if (reservationMisses >= 6) {
      setReservationMessage('Connection lost. Releasing reserved ID and trying again…', 'warning');
      try { await releaseReservation({ keepalive: true }); } catch (e) {}
      RESERVED_ID = null;
      stopReservationHeartbeat();
      const newId = await reserveNewId({ showWarning: true });
      if (newId && CURRENT) CURRENT.id = newId;
    }
  } finally {
    reservationHeartbeatBusy = false;
  }
}

function startReservationHeartbeat() {
  stopReservationHeartbeat();
  if (!RESERVED_ID) return;
  reservationTimer = setInterval(heartbeatTick, 10000);
}

function applyReservedIdToForm(id) {
  const clean = String(id || '').trim();
  stopReservationHeartbeat();
  RESERVED_ID = clean ? clean : null;
  const idRow = document.getElementById('idRow');
  const input = document.getElementById('user_id');
  if (input) input.value = clean;
  if (idRow) idRow.style.display = clean ? 'block' : 'none';
  if (clean) {
    rememberReservationId(clean);
    setReservationMessage('');
    startReservationHeartbeat();
  } else {
    forgetReservationId();
  }
}

async function restoreReservationFromStorage() {
  const stored = readStoredReservation();
  if (!stored) return '';
  const id = String(stored.id || '').trim();
  if (!id) return '';

  const ts = Number(stored.ts || 0);
  if (Number.isFinite(ts) && ts > 0) {
    const age = Date.now() - ts;
    if (age > RESERVATION_STALE_AFTER) {
      forgetReservationId();
      return '';
    }
  }

  applyReservedIdToForm(id);
  return id;
}

async function reserveNewId(options = {}) {
  const prior = (() => {
    if (RESERVED_ID) return RESERVED_ID;
    const stored = readStoredReservation();
    return stored && stored.id ? String(stored.id).trim() : '';
  })();
  if (prior) {
    try { await releaseReservation({ id: prior }); } catch (err) {}
  }
  applyReservedIdToForm('');
  try {
    const res = await apiGet(API_RESERVE_ID);
    const newId = res && res.ok && res.id ? res.id : '';
    if (!newId) throw new Error('reserve failed');
    applyReservedIdToForm(newId);
    return newId;
  } catch (err) {
    applyReservedIdToForm('');
    if (handleAuthError(err)) return '';
    if (options.showWarning !== false) {
      setReservationMessage('ID reserve failed. You can still press <b>Save</b> to create a user, then return to upload a face.', 'warning');
    }
    return '';
  }
}

function selectExistingUser(id, options = {}){
  const targetId = String(id || '').trim();
  if (!targetId) return;
  const candidates = Array.isArray(REGISTRY) ? REGISTRY : [];
  const existing = candidates.find(u => String(u.id || u.UserID || u.UserId || u.ID || '').trim() === targetId);
  if (!existing) {
    alert('Unable to find that user in Home Assistant.');
    return;
  }

  CURRENT = {
    ...blankProfile(existing.id || targetId),
    ...existing,
    groups: Array.isArray(existing.groups)
      ? [...existing.groups]
      : Array.isArray(existing.Groups)
      ? [...existing.Groups]
      : ['Default'],
  };
  CURRENT.face_removed = false;
  CURRENT.exit_permission = normalizeExitPermission(existing.exit_permission) || 'match';
  CURRENT.license_plate = sanitizeLicensePlateList(existing.license_plate || existing.LicensePlate || CURRENT.license_plate);
  if (!CURRENT.schedule_id && CURRENT.schedule_name) {
    CURRENT.schedule_id = idForName(CURRENT.schedule_name);
  }
  applyPausedScheduleToCurrent();

  RESERVED_ID = null;
  stopReservationHeartbeat();
  setReservationMessage('');
  forgetReservationId();

  const idRow = document.getElementById('idRow');
  if (idRow) idRow.style.display = 'block';
  const idInput = document.getElementById('user_id');
  if (idInput) idInput.value = CURRENT.id || targetId;
  document.getElementById('title').textContent = 'Edit User';

  fillForm();
  fillPhones();
  updateKeyHolderAvailability();
  updateFacePreviewState();

  if (options?.updateUrl !== false) {
    try {
      const url = new URL(location.href);
      url.searchParams.set('id', CURRENT.id || targetId);
      url.searchParams.delete('mode');
      history.replaceState(history.state || {}, '', url);
    } catch (err) {}
  }

  const nameInput = document.getElementById('name');
  if (nameInput) nameInput.focus();
}

// ---------- schedule id mapping helpers ----------
let SCHED_MAP = []; // [{id:"1001", name:"24/7 Access", label:"24/7 Access", display:"HA1 - 24/7 Access"}, ...]

function scheduleDisplayId(rawId){
  const text = String(rawId ?? '').trim();
  if (!/^\d+$/.test(text)) return '';
  const numeric = Number(text);
  if (!Number.isFinite(numeric) || numeric <= 0) return '';
  if (numeric >= 1000){
    const adjusted = numeric - 901;
    return adjusted > 0 ? `HA${adjusted}` : '';
  }
  if (numeric >= 100){
    return `HA${numeric}`;
  }
  return '';
}

function formatScheduleDisplay(rawId, label){
  const name = String(label ?? '').trim();
  const displayId = scheduleDisplayId(rawId);
  if (displayId && name) return `${displayId} - ${name}`;
  return displayId || name;
}

function todayIso(){
  const now = new Date();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  return `${now.getFullYear()}-${month}-${day}`;
}

function parseIsoDate(value){
  const text = String(value || '').trim();
  if (!text) return null;
  const match = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(text);
  if (!match) return null;
  const year = Number(match[1]);
  const month = Number(match[2]);
  const day = Number(match[3]);
  const candidate = new Date(year, month - 1, day);
  if (
    Number.isNaN(candidate.getTime())
    || candidate.getFullYear() !== year
    || candidate.getMonth() !== month - 1
    || candidate.getDate() !== day
  ){
    return null;
  }
  return candidate;
}

function computeAccessState(startStr, endStr){
  const startDate = parseIsoDate(startStr);
  const endDate = parseIsoDate(endStr);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  return {
    startDate,
    endDate,
    expired: !!(endDate && endDate <= today),
    notStarted: !!(startDate && startDate > today)
  };
}

function blankProfile(id = ''){
  return {
    id,
    name: '',
    groups: ['Default'],
    pin: '',
    phone: '',
    license_plate: [],
    face_url: '',
    face_status: '',
    face_active: false,
    face_removed: false,
    face_error_count: 0,
    schedule_name: '24/7 Access',
    schedule_id: '1001',
    key_holder: false,
    access_level: '',
    exit_permission: 'match',
    access_start: todayIso(),
    access_end: '',
    access_expired: false,
    access_in_future: false,
  };
}

function sanitizeCredentialPrompts(raw){
  const base = { ...DEFAULT_CREDENTIAL_PROMPTS };
  if (!raw || typeof raw !== 'object') return base;
  Object.keys(DEFAULT_CREDENTIAL_PROMPTS).forEach((key) => {
    if (typeof raw[key] === 'boolean') base[key] = raw[key];
  });
  if (typeof raw.phone !== 'boolean' && typeof raw.token === 'boolean') {
    base.phone = raw.token;
  }
  return base;
}

function sanitizeLicensePlateList(raw){
  const array = Array.isArray(raw) ? raw : [];
  const cleaned = [];
  const seen = new Set();
  for (const entry of array){
    let text = '';
    if (typeof entry === 'string'){ text = entry.trim(); }
    else if (entry && typeof entry === 'object'){
      text = String(entry.Plate || entry.plate || entry.value || entry.Value || '').trim();
    }
    if (!text) continue;
    const normalized = text.toUpperCase();
    if (seen.has(normalized)) continue;
    seen.add(normalized);
    cleaned.push(normalized);
    if (cleaned.length >= MAX_LICENSE_PLATES) break;
  }
  return cleaned;
}

function collectLicensePlates(){
  const container = document.getElementById('licensePlateList');
  const values = [];
  if (container){
    container.querySelectorAll('input[data-plate-index]').forEach(input => {
      values.push((input.value || '').trim());
    });
  } else if (Array.isArray(CURRENT?.license_plate)){
    values.push(...CURRENT.license_plate);
  }
  return sanitizeLicensePlateList(values);
}

function renderLicensePlateInputs(focusIndex){
  const container = document.getElementById('licensePlateList');
  if (!container || !CURRENT) return;
  if (!Array.isArray(CURRENT.license_plate)) CURRENT.license_plate = [];
  CURRENT.license_plate = CURRENT.license_plate.slice(0, MAX_LICENSE_PLATES);
  container.innerHTML = '';
  const plates = CURRENT.license_plate;
  if (!plates.length){
    const empty = document.createElement('div');
    empty.className = 'muted small';
    empty.textContent = 'No license plates assigned.';
    container.appendChild(empty);
  } else {
    plates.forEach((value, index) => {
      const row = document.createElement('div');
      row.className = 'input-group mb-2 license-plate-row';
      const input = document.createElement('input');
      input.className = 'form-control license-plate-input';
      input.placeholder = 'e.g. ABC123';
      input.value = value || '';
      input.setAttribute('data-plate-index', index);
      input.addEventListener('input', (ev) => {
        CURRENT.license_plate[index] = ev.target.value;
      });
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-outline-danger';
      btn.innerHTML = '<i class="bi bi-trash"></i>';
      btn.addEventListener('click', () => {
        CURRENT.license_plate.splice(index, 1);
        renderLicensePlateInputs();
      });
      row.appendChild(input);
      row.appendChild(btn);
      container.appendChild(row);
    });
  }
  const addBtn = document.getElementById('addLicensePlateBtn');
  if (addBtn){
    addBtn.disabled = !CREDENTIAL_PROMPTS.anpr || CURRENT.license_plate.length >= MAX_LICENSE_PLATES;
    addBtn.onclick = () => {
      if (!CREDENTIAL_PROMPTS.anpr) return;
      if (!Array.isArray(CURRENT.license_plate)) CURRENT.license_plate = [];
      if (CURRENT.license_plate.length >= MAX_LICENSE_PLATES) return;
      CURRENT.license_plate.push('');
      renderLicensePlateInputs(CURRENT.license_plate.length - 1);
    };
  }
  if (typeof focusIndex === 'number'){
    requestAnimationFrame(() => {
      const focusInput = container.querySelector(`input[data-plate-index="${focusIndex}"]`);
      if (focusInput){
        focusInput.focus();
        focusInput.select();
      }
    });
  }
}

function applyCredentialPrompts(){
  CREDENTIAL_PROMPTS = sanitizeCredentialPrompts(CREDENTIAL_PROMPTS);
  const pinRow = document.getElementById('pinRow');
  if (pinRow){
    pinRow.style.display = CREDENTIAL_PROMPTS.code ? '' : 'none';
  }
  const phoneRow = document.getElementById('phoneRow');
  if (phoneRow){
    phoneRow.style.display = CREDENTIAL_PROMPTS.phone ? '' : 'none';
  }
  const faceSection = document.getElementById('faceSection');
  if (faceSection){
    faceSection.style.display = CREDENTIAL_PROMPTS.face ? '' : 'none';
  }
  const faceErrorRow = document.getElementById('faceErrorRow');
  if (faceErrorRow){
    faceErrorRow.style.display = CREDENTIAL_PROMPTS.face ? '' : 'none';
  }
  if (!CREDENTIAL_PROMPTS.face){
    const local = document.getElementById('pLocal');
    const remote = document.getElementById('pRemote');
    if (local) local.style.display = 'none';
    if (remote) remote.style.display = 'none';
  }
  const anprSection = document.getElementById('anprSection');
  if (anprSection){
    anprSection.style.display = CREDENTIAL_PROMPTS.anpr ? '' : 'none';
    renderLicensePlateInputs();
  }
}

function buildScheduleMap(){
  EXIT_CLONES = buildExitCloneMap(SCHEDULES);
  const idForName = (name) => {
    if (!name) return '';
    if (SCHEDULE_IDS && typeof SCHEDULE_IDS === 'object'){
      const direct = SCHEDULE_IDS[name];
      if (direct) return String(direct);
      const lower = String(name).toLowerCase();
      const match = Object.keys(SCHEDULE_IDS).find(key => key.toLowerCase() === lower);
      if (match) return String(SCHEDULE_IDS[match]);
    }
    return '';
  };
  const out = [
    { id: idForName('24/7 Access') || '1001', name: '24/7 Access', label: '24/7 Access' },
    { id: idForName('No Access') || '1002',   name: 'No Access',   label: 'No Access' }
  ];
  const entries = Object.entries(SCHEDULES || {})
    .filter(([name, spec]) => name !== '24/7 Access' && name !== 'No Access' && !scheduleIsExitClone(name, spec))
    .map(([name]) => name)
    .sort((a, b) => a.localeCompare(b));
  const base = 1003;
  entries.forEach((name, i) => {
    const id = idForName(name) || String(base + i);
    out.push({ id, name, label: name });
  });
  SCHED_MAP = out.map(item => ({ ...item, display: formatScheduleDisplay(item.id, item.label) }));
}

function ensureExitPermissionAvailability(){
  const exitEl = document.getElementById('exit_permission');
  if (!exitEl) return;
  const scheduleEl = document.getElementById('schedule');
  const selectedId = scheduleEl ? scheduleEl.value : (CURRENT && CURRENT.schedule_id ? CURRENT.schedule_id : '');
  const scheduleName = nameForId(selectedId);
  const hasWorking = scheduleHasWorkingExitClone(scheduleName);
  Array.from(exitEl.options).forEach(opt => {
    if (opt.value === 'working_days'){
      opt.disabled = !hasWorking;
    }
  });
  if (exitEl.value === 'working_days' && !hasWorking){
    exitEl.value = 'match';
    if (CURRENT) CURRENT.exit_permission = 'match';
  }
}
function optionLabel(item){
  const display = item && typeof item === 'object'
    ? (item.display || formatScheduleDisplay(item.id, item.label))
    : '';
  return display || `${item.id} - ${item.label}`;
}
function nameForId(id){
  const x = SCHED_MAP.find(s => s.id === String(id));
  return x ? x.name : '24/7 Access';
}
function idForName(name){
  const lower = String(name || '').toLowerCase();
  if (lower === '24/7 access' || lower === '24/7') return '1001';
  if (lower === 'no access' || lower === 'never')  return '1002';
  const x = SCHED_MAP.find(s => s.name.toLowerCase() === lower);
  return x ? x.id : '1001';
}

async function releaseReservation(options = {}){
  const explicit = Object.prototype.hasOwnProperty.call(options || {}, 'id')
    ? String(options.id || '').trim()
    : '';
  const id = explicit || RESERVED_ID;
  if (!id) return;

  const releasingActive = !explicit || explicit === RESERVED_ID;
  if (releasingActive) {
    applyReservedIdToForm('');
  }

  const payload = JSON.stringify({ id });
  if (options.keepalive && navigator.sendBeacon) {
    try {
      const blob = new Blob([payload], { type: 'application/json' });
      const ok = navigator.sendBeacon(API_RELEASE_ID, blob);
      if (ok) return;
    } catch (err) {}
  }
  try {
    await fetchWithAuth(API_RELEASE_ID, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: payload,
      keepalive: !!options.keepalive
    });
  } catch (err) {}
}

window.addEventListener('beforeunload', () => {
  if (RESERVED_ID) {
    stopReservationHeartbeat();
    releaseReservation({ keepalive: true });
  }
});

/* -------------------- load -------------------- */
async function load(){
  setBusy(true);
  try{
    let state;
    try {
      state = await apiGet(API_STATE);
    } catch (err) {
      if (handleAuthError(err)) return;
      console.warn('Failed to load Akuvox state', err);
      alert('Failed to load Akuvox data. Default values will be used until the connection succeeds.');
      state = { schedules: {}, registry_users: [] };
    }
    ANY_ALARM_CAPABLE = false;
    if (state && typeof state === 'object'){
      const caps = state.capabilities;
      if (caps && typeof caps === 'object' && typeof caps.alarm_relay === 'boolean'){
        ANY_ALARM_CAPABLE = caps.alarm_relay;
      }
      if (!ANY_ALARM_CAPABLE && Array.isArray(state.devices)){
        ANY_ALARM_CAPABLE = state.devices.some(dev => {
          if (!dev || typeof dev !== 'object') return false;
          const roles = dev.relay_roles || {};
          const norm = (val) => String(val ?? '').toLowerCase().replace(/[\s-]+/g, '_');
          const a = norm(roles.relay_a);
          const b = norm(roles.relay_b);
          return a === 'alarm' || a === 'door_alarm' || b === 'alarm' || b === 'door_alarm';
        });
      }
    }
    updateKeyHolderAvailability();
    CREDENTIAL_PROMPTS = sanitizeCredentialPrompts(state?.credential_prompts);
    applySchedulesUpdate(state?.schedules || {}, state?.schedule_ids || {});
    REGISTRY = state.registry_users || [];
    DEVICES = state.devices || [];

    // Load phones (notify services from HA mobile app)
    try {
      const resp = await apiGet(API_PHONES);
      PHONES = resp.phones || [];
    } catch (err) {
      if (handleAuthError(err)) return;
      console.warn('Failed to load phone list', err);
      PHONES = [];
    }

    const params = new URLSearchParams(location.search);
    const id = (params.get('id') || '').trim();
    const modeParam = (params.get('mode') || '').toLowerCase();
    const startInEditMode = modeParam === 'edit';
    let handledBySelect = false;

    if (id) {
      const hasMatch = (REGISTRY || []).some(u => String(u.id || u.UserID || u.UserId || u.ID || '') === id);
      if (hasMatch) {
        selectExistingUser(id, { updateUrl: false });
        handledBySelect = true;
      } else {
        CURRENT = blankProfile(id);
        RESERVED_ID = null;
        stopReservationHeartbeat();
        setReservationMessage('');
        forgetReservationId();
        document.getElementById('title').textContent = 'Edit User';
        document.getElementById('idRow').style.display = 'block';
        document.getElementById('user_id').value = CURRENT.id;
      }
    } else if (!startInEditMode) {
      document.getElementById('title').textContent = 'Add User';
      CURRENT = blankProfile('');
      const restoredId = await restoreReservationFromStorage();
      if (restoredId) {
        CURRENT.id = restoredId;
        if (!CURRENT.schedule_id) CURRENT.schedule_id = '1001';
      } else {
        const newId = await reserveNewId();
        if (newId) {
          CURRENT.id = newId;
          CURRENT.schedule_id = '1001';
        } else {
          const idRow = document.getElementById('idRow');
          if (idRow) idRow.style.display = 'none';
        }
      }
    } else {
      CURRENT = blankProfile('');
      applyReservedIdToForm('');
      setReservationMessage('');
      document.getElementById('title').textContent = 'Edit User';
      const idRow = document.getElementById('idRow');
      if (idRow) idRow.style.display = 'none';
    }

    if (!handledBySelect) {
      fillForm();
      fillPhones();
    }
  } finally {
    setBusy(false);
  }
}

function scheduleOptionsHtml(){
  buildScheduleMap();
  return SCHED_MAP.map(it => `<option value="${it.id}">${optionLabel(it)}</option>`).join('');
}

function fillForm(){
  document.getElementById('name').value = CURRENT.name || '';
  document.getElementById('pin').value = CURRENT.pin || '';
  document.getElementById('phone').value = CURRENT.phone || '';
  CURRENT.license_plate = Array.isArray(CURRENT.license_plate) ? [...CURRENT.license_plate] : [];
  renderLicensePlateInputs();

  // Build schedule select with ids
  document.getElementById('schedule').innerHTML = scheduleOptionsHtml();
  const selEl = document.getElementById('schedule');
  const ids = new Set(Array.from(selEl.options).map(opt => opt.value));
  let selectedId = CURRENT.schedule_id ? String(CURRENT.schedule_id) : '';
  if (!selectedId || !ids.has(selectedId)) {
    selectedId = idForName(CURRENT.schedule_name || '24/7 Access');
  }
  if (!ids.has(selectedId)) {
    selectedId = '1001';
  }
  selEl.value = selectedId;
  CURRENT.schedule_id = selectedId;
  CURRENT.schedule_name = nameForId(selectedId);
  if (!selEl._exitBound){
    selEl.addEventListener('change', () => {
      const val = selEl.value || '1001';
      CURRENT.schedule_id = val;
      CURRENT.schedule_name = nameForId(val);
      ensureExitPermissionAvailability();
    });
    selEl._exitBound = true;
  }

  const exitSelect = document.getElementById('exit_permission');
  if (exitSelect){
    if (!exitSelect._bound){
      exitSelect.addEventListener('change', () => {
        const normalized = normalizeExitPermission(exitSelect.value) || 'match';
        if (CURRENT) CURRENT.exit_permission = normalized;
      });
      exitSelect._bound = true;
    }
    const desiredExit = normalizeExitPermission(CURRENT.exit_permission) || 'match';
    exitSelect.value = desiredExit;
    CURRENT.exit_permission = desiredExit;
    ensureExitPermissionAvailability();
  }
  const exitRow = document.getElementById('exitPermissionRow');
  if (exitRow) exitRow.style.display = '';

  const startInput = document.getElementById('access_start');
  if (startInput){
    const normalizedStart = (CURRENT.access_start && String(CURRENT.access_start).trim())
      ? String(CURRENT.access_start).trim()
      : todayIso();
    startInput.value = normalizedStart;
    CURRENT.access_start = normalizedStart;
    if (!startInput._expiryBound){
      const handler = () => updateAccessExpirationUI();
      startInput.addEventListener('change', handler);
      startInput.addEventListener('input', handler);
      startInput._expiryBound = true;
    }
  }

  const endInput = document.getElementById('access_end');
  if (endInput){
    const normalizedEnd = (CURRENT.access_end && String(CURRENT.access_end).trim())
      ? String(CURRENT.access_end).trim()
      : '';
    endInput.value = normalizedEnd;
    CURRENT.access_end = normalizedEnd;
    if (!endInput._expiryBound){
      const handler = () => updateAccessExpirationUI();
      endInput.addEventListener('change', handler);
      endInput.addEventListener('input', handler);
      endInput._expiryBound = true;
    }
  }

  updateAccessExpirationUI();

  const keyInput = document.getElementById('key_holder');
  if (keyInput){
    keyInput.checked = ANY_ALARM_CAPABLE && !!CURRENT.key_holder;
  }
  updateKeyHolderAvailability();

  const localHelp = document.getElementById('localHelp');
  if (localHelp && !localHelp.innerHTML){
    if (CURRENT.id){
      localHelp.innerHTML = `<span class="muted">If you select a photo, it will be saved as <code>/api/AK_AC/FaceData/${CURRENT.id}.jpg</code> when you press <b>Save</b>.</span>`;
    } else {
      localHelp.innerHTML = `<span class="muted">ID reserve failed. You can still press <b>Save</b> to create a user, then return to upload a face.</span>`;
    }
  }
  updateDeviceIdsDisplay();
  applyCredentialPrompts();
  if (CREDENTIAL_PROMPTS.face && hasExistingFace()) {
    showPanel('local');
  }
  const faceErrorRow = document.getElementById('faceErrorRow');
  const faceErrorCount = document.getElementById('faceErrorCount');
  if (faceErrorCount){
    const count = Number(CURRENT.face_error_count || 0);
    faceErrorCount.textContent = Number.isFinite(count) ? String(count) : '0';
  }
  if (faceErrorRow){
    faceErrorRow.style.display = '';
  }
  bindFaceFileInput();
  bindRemoveFaceButton();
  updateFacePreviewState();
}

function bindRemoveFaceButton() {
  const btn = document.getElementById('removeFaceBtn');
  if (!btn || btn._bound) return;
  btn.addEventListener('click', async (ev) => {
    if (ev) ev.preventDefault();
    if (!CURRENT || !CURRENT.id) return;
    if (!hasExistingFace()) return;
    const ok = confirm('Remove the saved face photo for this user?');
    if (!ok) return;
    setBusy(true);
    try {
      await apiPost(API_ACTION, { action: 'remove_face', payload: { id: CURRENT.id } });
      CURRENT.face_removed = true;
      CURRENT.face_url = '';
      CURRENT.face_status = '';
      CURRENT.face_active = false;
      const input = document.getElementById('facefile');
      if (input) {
        input.value = '';
        input._processedFace = null;
        input._processedToken = null;
      }
      updateFacePreviewState();
    } catch (err) {
      if (handleAuthError(err)) return;
      alert('Failed to remove face photo: ' + (err && err.message ? err.message : err));
    } finally {
      setBusy(false);
      updateRemoveFaceButton();
    }
  });
  btn._bound = true;
}

function updateAccessExpirationUI(){
  const startInput = document.getElementById('access_start');
  const endInput = document.getElementById('access_end');
  const notice = document.getElementById('accessExpiryNotice');
  const reactivateRow = document.getElementById('accessReactivateRow');
  if (!startInput || !endInput) return;

  const startVal = String(startInput.value || '').trim();
  const endVal = String(endInput.value || '').trim();
  const state = computeAccessState(startVal, endVal);

  if (CURRENT){
    CURRENT.access_start = startVal || '';
    CURRENT.access_end = endVal || '';
    CURRENT.access_expired = !!state.expired;
    CURRENT.access_in_future = !!state.notStarted;
  }

  if (state.expired){
    if (notice){
      const label = state.endDate ? state.endDate.toISOString().slice(0, 10) : '';
      notice.textContent = label ? `Access expired on ${label}.` : 'Access expired.';
      notice.className = 'mb-2 fw-semibold text-danger';
      notice.style.display = '';
    }
    if (reactivateRow){
      reactivateRow.style.display = 'flex';
    }
    return;
  }

  if (state.notStarted){
    if (notice){
      const label = state.startDate ? state.startDate.toISOString().slice(0, 10) : '';
      notice.textContent = label ? `Access starts on ${label}.` : 'Access not yet active.';
      notice.className = 'mb-2 fw-semibold text-warning';
      notice.style.display = '';
    }
    if (reactivateRow){
      reactivateRow.style.display = 'none';
    }
    return;
  }

  if (notice){
    notice.style.display = 'none';
  }
  if (reactivateRow){
    reactivateRow.style.display = 'none';
  }
}

function reactivateAccess(evt){
  if (evt) evt.preventDefault();
  const startInput = document.getElementById('access_start');
  const endInput = document.getElementById('access_end');
  if (startInput){
    startInput.value = todayIso();
  }
  if (endInput){
    endInput.value = '';
  }
  updateAccessExpirationUI();
  if (startInput){
    startInput.focus();
  }
}

// Populate the Remote Enrolment dropdown with HA phone notify services
function fillPhones(){
  const sel = document.getElementById('device');  // keeping id=device for layout compatibility
  sel.innerHTML = '';
  if (!PHONES.length){
    sel.innerHTML = `<option value="" disabled selected>(no phones found)</option>`;
    sel.disabled = true;
  }else{
    sel.disabled = false;
    const sorted = [...PHONES].sort((a,b) => (a.name || a.service || '').localeCompare(b.name || b.service || ''));
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select phone…';
    placeholder.disabled = true;
    placeholder.selected = true;
    sel.appendChild(placeholder);
    sorted.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.service;            // e.g. "mobile_app_johns_iphone"
      opt.textContent = p.name || p.service;
      sel.appendChild(opt);
    });
  }
  const resSpan = document.getElementById('remoteResult');
  if (resSpan) resSpan.textContent = '';
}

/* -------------------- save: user core + optional face upload + optional remote enrol -------------------- */
async function save(){
  if (!CURRENT){
    alert('Form not ready yet. Please reload the page.');
    return;
  }
  if (BUSY) return;
  setBusy(true);
  try{
    // Ensure we have or reserve an ID
    if (!CURRENT.id){
      try{
        const res = await apiGet(API_RESERVE_ID);
        if (res && res.ok && res.id) {
          CURRENT.id = res.id;
          RESERVED_ID = CURRENT.id;
          document.getElementById('idRow').style.display = 'block';
          document.getElementById('user_id').value = CURRENT.id;
        }
      }catch(err){
        if (handleAuthError(err)) return;
      }
      if (!CURRENT.id){
        alert('Could not reserve a user ID. Please try again.');
        return;
      }
    }

    const scheduleEl = document.getElementById('schedule');
    let selectedScheduleId = scheduleEl && scheduleEl.value ? scheduleEl.value : '1001';
    let selectedScheduleName = nameForId(selectedScheduleId);

    const prompts = sanitizeCredentialPrompts(CREDENTIAL_PROMPTS);
    const payload = {
      name: document.getElementById('name').value.trim(),
      groups: CURRENT.groups || ['Default'],
      schedule_id: selectedScheduleId,          // drives ScheduleRelay on backend
      schedule_name: selectedScheduleName,      // for UI/state clarity
      key_holder: ANY_ALARM_CAPABLE ? document.getElementById('key_holder').checked : false,
    };

    const exitSelect = document.getElementById('exit_permission');
    const exitPermissionValue = normalizeExitPermission(exitSelect ? exitSelect.value : CURRENT.exit_permission) || 'match';
    payload.exit_permission = exitPermissionValue;
    CURRENT.exit_permission = exitPermissionValue;

    if (prompts.code){
      const pinInput = document.getElementById('pin');
      const pinValue = pinInput ? pinInput.value.trim() : '';
      const priorPin = typeof CURRENT.pin === 'string' ? CURRENT.pin.trim() : '';
      if (pinValue || priorPin){
        if (pinValue !== priorPin){
          payload.pin = pinValue;
        }
      }
      CURRENT.pin = pinValue;
    }

    const phoneInput = document.getElementById('phone');
    const phoneValue = phoneInput ? phoneInput.value.trim() : '';
    const hadPhone = !!(CURRENT && typeof CURRENT.phone === 'string' && CURRENT.phone.trim());
    if (prompts.phone || phoneValue || hadPhone){
      payload.phone = phoneValue;
      CURRENT.phone = phoneValue;
    }

    if (prompts.anpr){
      const plates = collectLicensePlates();
      payload.license_plate = plates;
      CURRENT.license_plate = [...plates];
    }

    const accessStartInput = document.getElementById('access_start');
    const accessEndInput = document.getElementById('access_end');
    const accessStartVal = accessStartInput ? accessStartInput.value.trim() : '';
    const accessEndVal = accessEndInput ? accessEndInput.value.trim() : '';
    payload.access_start = accessStartVal || '';
    payload.access_end = accessEndVal || '';
    CURRENT.access_start = payload.access_start;
    CURRENT.access_end = payload.access_end;

    // Save/update the profile against the reserved ID
    const saveRes = await fetchWithAuth(API_EDIT_USER, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ id: CURRENT.id, ...payload })
    });
    if (!saveRes.ok){
      const txt = await saveRes.text();
      const err = buildError(saveRes, txt);
      handleAuthError(err);
      throw err;
    }
    try { await saveRes.json(); } catch {}

    // If a photo is selected, upload it now
    const fileInput = document.getElementById('facefile');
    if (fileInput.files && fileInput.files[0]){
      const selectedFile = fileInput.files[0];
      const token = `${selectedFile.name}:${selectedFile.size}:${selectedFile.lastModified}`;
      let faceFile = null;
      if (fileInput._processedFace && fileInput._processedToken === token) {
        faceFile = fileInput._processedFace;
      } else {
        try {
          faceFile = await prepareFaceFile(selectedFile);
        } catch (err) {
          alert(err && err.message ? err.message : err);
          return;
        }
      }
      const fd = new FormData();
      fd.append('id', CURRENT.id);
      fd.append('file', faceFile);
      const r = await fetchWithAuth(API_UPLOAD_FACE, {
        method: 'POST',
        body: fd
      });
      if (!r.ok){
        const t = await r.text();
        const err = buildError(r, t);
        handleAuthError(err);
        throw err;
      }
      try { await r.json(); } catch {}
    }

    // If Remote panel is visible and a phone is selected, auto-send enrolment request now
    const remoteVisible = document.getElementById('pRemote').style.display !== 'none';
    const phoneSel = document.getElementById('device');
    const phoneService = phoneSel && phoneSel.value ? phoneSel.value : '';
    if (remoteVisible && phoneService){
      try{
        await apiPost(API_REMOTE_ENROL, {
          id: CURRENT.id,
          phone_service: phoneService,
          name: document.getElementById('name').value.trim()
        });
        const resSpan = document.getElementById('remoteResult');
        if (resSpan) resSpan.textContent = 'Enrolment request sent.';
      }catch(e){
        if (handleAuthError(e)) return;
        const resSpan = document.getElementById('remoteResult');
        if (resSpan) resSpan.textContent = 'Failed to send enrolment request.';
      }
    }

    // Back to list
    stopReservationHeartbeat();
    forgetReservationId();
    RESERVED_ID = null;
    openInApp('user-overview', {}, { replaceState: true });
  } catch (e){
    if (handleAuthError(e)) return;
    alert('Save failed: ' + (e && e.message ? e.message : e));
  } finally {
    setBusy(false);
  }
}

/* -------------------- toggle panels -------------------- */
async function cancelEdit(evt){
  if (evt) evt.preventDefault();
  stopReservationHeartbeat();
  await releaseReservation();
  openInApp('user-overview', {}, { replaceState: true });
}

function showPanel(which){
  document.getElementById('pLocal').style.display = which === 'local' ? 'block':'none';
  document.getElementById('pRemote').style.display = which === 'remote' ? 'block':'none';
}
</script>

<div class="container py-3 container-narrow">
  <div class="d-flex align-items-center gap-2">
    <h2 id="title" class="m-0">User</h2>
    <span id="busy" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display:none;"></span>
  </div>

  <div class="card p-3 mt-3">
    <div id="idRow" class="mb-3" style="display:none;">
      <label class="form-label">User ID</label>
      <input id="user_id" class="form-control" readonly />
      <div class="form-text muted">ID is reserved locally so your selected photo can upload when you press <b>Save</b>.</div>
    </div>

    <div id="deviceIdsRow" class="mb-3" style="display:none;">
      <label class="form-label">Device User IDs</label>
      <div id="deviceIdsList" class="border rounded p-2 bg-dark-subtle"></div>
      <div class="form-text muted">IDs shown are unique to each Akuvox device.</div>
    </div>

    <div class="mb-3"><label class="form-label">Name</label><input id="name" class="form-control"/></div>

    <div class="mb-3" id="pinRow">
      <label class="form-label">PIN</label>
      <div class="input-group">
        <input id="pin" class="form-control"/>
        <button class="btn btn-outline-secondary" onclick="document.getElementById('pin').value = String(Math.floor(1000+Math.random()*9000))">Random</button>
      </div>
    </div>

    <div class="mb-3" id="faceSection">
      <label class="form-label">Face Recognition</label>
      <div class="face-options mb-2">
        <button class="btn btn-outline-light btn-toggle" onclick="showPanel('local')"><i class="bi bi-upload me-1"></i>Local enrolment</button>
        <button class="btn btn-outline-light btn-toggle" onclick="showPanel('remote')"><i class="bi bi-wifi me-1"></i>Remote enrolment</button>
      </div>
    </div>

    <!-- Local enrolment panel -->
    <div id="pLocal" class="mt-2" style="display:none;">
      <div class="mb-2" id="localHelp"></div>
      <div class="mb-2">
        <input id="facefile" class="form-control" type="file" accept=".jpg,.jpeg,.png,image/jpeg,image/png" />
        <div class="uploader-hint mt-1">Choose a clear, front-facing photo (Max File Size: 2M, Format: .jpg/.png). Larger files are resized and saved as JPG before upload when you press <b>Save</b>.</div>
      </div>
      <div class="face-preview-frame">
        <span id="facePreviewPlaceholder" class="face-preview-placeholder">No photo selected</span>
        <img id="facePreview" alt="Selected face photo preview" />
      </div>
      <button type="button" class="btn btn-outline-danger btn-sm mt-2" id="removeFaceBtn" style="display:none;">
        <i class="bi bi-trash me-1"></i>Remove face photo
      </button>
    </div>

    <!-- Remote enrolment panel -->
    <div id="pRemote" class="mt-2" style="display:none;">
      <div class="mb-2 muted">Choose a phone (Home Assistant app) to receive an enrolment prompt:</div>
      <div class="row g-2 align-items-end">
        <div class="col-sm-6">
          <label class="form-label">Phone</label>
          <select id="device" class="form-select"></select>
        </div>
      </div>
      <div class="mt-2 muted" id="remoteResult"></div>
    </div>
    <div id="faceErrorRow" class="form-text muted mt-2">Face sync errors: <span id="faceErrorCount">0</span></div>

    <div class="mb-3" id="phoneRow"><label class="form-label">Phone number</label><input id="phone" class="form-control"/></div>

    <div class="mb-3" id="anprSection">
      <label class="form-label">License Plates (ANPR)</label>
      <div id="licensePlateList"></div>
      <button type="button" class="btn btn-outline-light btn-sm mt-2" id="addLicensePlateBtn"><i class="bi bi-plus-lg me-1"></i>Add plate</button>
      <div class="form-text muted">Enter up to five vehicle plates.</div>
    </div>

    <div class="mb-3" id="scheduleRow">
      <label class="form-label">Access Schedule</label>
      <select id="schedule" class="form-select"></select>
      <div class="form-text muted">Need a new schedule? Open <b>Global Settings → Access Schedules</b> to build one, then come back and select it here.</div>
    </div>

    <div class="mb-3" id="exitPermissionRow">
      <label class="form-label">Exit permissions</label>
      <select id="exit_permission" class="form-select">
        <option value="match">Match access schedule</option>
        <option value="working_days">Permit exit on working days</option>
        <option value="always">Always permit exit</option>
      </select>
      <div class="form-text muted">Controls schedules applied on exit-only devices.</div>
    </div>

    <div class="mb-3" id="accessWindow">
      <div id="accessReactivateRow" class="mb-2" style="display:none;">
        <button type="button" class="btn btn-outline-success btn-sm" onclick="reactivateAccess(event)"><i class="bi bi-arrow-counterclockwise me-1"></i>Reactivate access</button>
      </div>
      <div id="accessExpiryNotice" class="mb-2 fw-semibold text-danger" style="display:none;"></div>
      <div class="row g-2">
        <div class="col-md-6">
          <label class="form-label">Access Start</label>
          <input id="access_start" type="date" class="form-control" />
        </div>
        <div class="col-md-6">
          <label class="form-label">Access End</label>
          <input id="access_end" type="date" class="form-control" />
        </div>
      </div>
      <div class="form-text muted mt-2">The start date defaults to today. Leave the end date empty to keep the user active indefinitely.</div>
    </div>

    <div class="form-check mb-3" id="keyHolderRow">
      <input class="form-check-input" type="checkbox" id="key_holder">
      <label class="form-check-label" for="key_holder">Key Holder (Disarm alarm and permit entry)</label>
    </div>

    <div class="action-buttons mb-3">
      <button class="btn btn-success" onclick="save()" data-busy-lock><i class="bi bi-check2-circle me-1"></i>Save</button>
      <a class="btn btn-secondary" href="#" onclick="cancelEdit(event)"><i class="bi bi-x-circle me-1"></i>Cancel</a>
    </div>

  </div>
</div>
<script>load()</script>
</body>
</html>
