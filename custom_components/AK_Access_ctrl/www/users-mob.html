<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox User Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" crossorigin="anonymous" />
  <style>
    :root{ --bg:#0b1320; --card:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc; }
    body{ background:var(--bg); color:var(--text); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .container-narrow{ max-width:960px; margin:0 auto; }
    .card{ background:#111a2b; border:1px solid #1b2942; }
    .card + .card{ margin-top:1.5rem; }
    label{ color:#fff; }
    .muted{ color:var(--muted); }
    .btn-toggle{ width: 220px; }
    .uploader-hint { font-size: .9rem; color: var(--muted); }
    .form-text code { color: #c7dfff; }
    .face-options{ display:flex; gap:0.5rem; flex-wrap:wrap; }
    .action-buttons{ display:flex; gap:0.5rem; flex-wrap:wrap; }
    .license-plate-row .btn{ min-width:3rem; }
    .license-plate-input{text-transform:uppercase; }
    @media (max-width: 992px){
      .container-narrow{ max-width:100%; }
    }
    @media (max-width: 720px){
      .container-narrow{ padding:0.75rem; }
      .card{ padding:1.25rem; }
      .btn-toggle{ width:100%; }
      .face-options{ flex-direction:column; }
      .action-buttons{ flex-direction:column; }
      .action-buttons .btn, .action-buttons a{ width:100%; }
    }
  </style>
</head>
<body>
<script>
/* -------------------- auth + helpers -------------------- */
(function () {
  const qs = new URLSearchParams(location.search);
  const qsToken = qs.get('token');
  if (qsToken) sessionStorage.setItem('akuvox_ll_token', qsToken);
})();
function persistTokens(access, refresh) {
  if (!access) return null;
  const payload = { access_token: access };
  if (refresh) payload.refresh_token = refresh;
  try { sessionStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  try { localStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  return access;
}

function extractTokenFromAuth(auth) {
  if (!auth || typeof auth !== 'object') return null;
  const access = auth.accessToken
    || auth.access_token
    || auth?.token?.access_token
    || auth?.data?.access_token
    || null;
  const refresh = auth.refreshToken
    || auth.refresh_token
    || auth?.token?.refresh_token
    || auth?.data?.refresh_token
    || null;
  if (access) {
    return persistTokens(access, refresh);
  }
  return null;
}

function scanTokenStorage(storage) {
  if (!storage) return null;
  try {
    const raw = storage.getItem('hassTokens');
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {
        if (typeof raw === 'string' && raw.trim()) {
          return persistTokens(raw.trim());
        }
      }
    }
    for (const key of Object.keys(storage)) {
      if (!/auth|token|hass/i.test(key)) continue;
      try {
        const parsed = JSON.parse(storage.getItem(key));
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {}
    }
  } catch (err) {}
  return null;
}

function tokenFromWindow(win) {
  if (!win) return null;
  let token = null;
  token = scanTokenStorage(win.sessionStorage) || scanTokenStorage(win.localStorage);
  if (token) return token;

  token = extractTokenFromAuth(win.hassAuth)
    || extractTokenFromAuth(win.auth)
    || extractTokenFromAuth(win.AK_AC_HA_AUTH)
    || null;
  if (token) return token;

  try {
    const conn = win.hassConnection;
    if (conn && typeof conn.then === 'function') {
      conn.then((resolved) => {
        try {
          extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
        } catch (err) {}
      }).catch(() => {});
    } else if (conn) {
      token = extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      if (token) return token;
    }
  } catch (err) {}

  return null;
}

function walkAuthWindows(start) {
  const visited = new Set();
  let current = start;
  while (current && !visited.has(current)) {
    const token = tokenFromWindow(current);
    if (token) return token;
    visited.add(current);

    let next = null;
    try {
      next = current.parent;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    try {
      next = current.opener;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    break;
  }
  return null;
}

(function bootstrapAuthWatchers() {
  const seen = new WeakSet();
  function attach(win) {
    if (!win || seen.has(win)) return;
    seen.add(win);
    try { extractTokenFromAuth(win.hassAuth || win.auth || win.AK_AC_HA_AUTH); } catch (err) {}
    try {
      const conn = win.hassConnection;
      if (conn && typeof conn.then === 'function') {
        conn.then((resolved) => {
          try {
            extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
          } catch (err) {}
        }).catch(() => {});
      } else if (conn) {
        extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      }
    } catch (err) {}
    try {
      if (win.parent && win.parent !== win) attach(win.parent);
    } catch (err) {}
    try {
      if (win.opener) attach(win.opener);
    } catch (err) {}
  }
  attach(window);
})();

function findHaToken(){
  const existing = sessionStorage.getItem('akuvox_ll_token');
  if (existing) return existing;
  const token = walkAuthWindows(window);
  if (token) {
    try { sessionStorage.setItem('akuvox_ll_token', token); } catch (err) {}
  }
  return token;
}
const SAME_ORIGIN = { credentials: 'same-origin' };
const REJECTED_TOKENS = new Set();

const AUTH_SIG_KEY = 'akuvox_auth_sig';

function readAuthSigFrom(search = location.search){
  try {
    const params = new URLSearchParams(search);
    const value = params.get('authSig');
    return value || '';
  } catch (err) {
    return '';
  }
}

function rememberAuthSig(value){
  if (!value) return;
  try { sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { window.AK_AC_AUTH_SIG = value; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      const parent = window.parent;
      try { parent.sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.AK_AC_AUTH_SIG = value; } catch (err) {}
    }
  } catch (err) {}
}

function currentAuthSig(){
  const fromUrl = readAuthSigFrom();
  if (fromUrl) {
    rememberAuthSig(fromUrl);
    return fromUrl;
  }

  const sources = [
    () => {
      try { return sessionStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return localStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return window.AK_AC_AUTH_SIG || null; } catch (err) { return null; }
    },
    () => {
      try {
        if (window.parent && window.parent !== window) {
          const parent = window.parent;
          return parent.AK_AC_AUTH_SIG
            || (parent.sessionStorage && parent.sessionStorage.getItem(AUTH_SIG_KEY))
            || (parent.localStorage && parent.localStorage.getItem(AUTH_SIG_KEY));
        }
      } catch (err) {}
      return null;
    }
  ];

  for (const getter of sources) {
    const value = getter();
    if (value) {
      rememberAuthSig(value);
      return value;
    }
  }

  return '';
}

rememberAuthSig(readAuthSigFrom());

function nextBearerToken(){
  const token = findHaToken();
  if (!token) return null;
  if (REJECTED_TOKENS.has(token)) return null;
  return token;
}

async function fetchWithAuth(url, options = {}, { allowRetry = true } = {}){
  const originalHeaders = { ...(options.headers || {}) };
  let bearer = allowRetry ? nextBearerToken() : null;
  let usedBearer = !!bearer;
  const headers = { ...originalHeaders };
  if (bearer) headers['Authorization'] = 'Bearer ' + bearer;

  const response = await fetch(url, { ...SAME_ORIGIN, ...options, headers });

  if (allowRetry && usedBearer && (response.status === 401 || response.status === 403)){
    REJECTED_TOKENS.add(bearer);
    const retryToken = nextBearerToken();
    if (retryToken && retryToken !== bearer){
      return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: true });
    }
    return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: false });
  }

  return response;
}

function buildError(res, text){
  const message = `${res.status}: ${text || res.statusText || 'Request failed'}`;
  const err = new Error(message);
  err.status = res.status;
  err.body = text;
  return err;
}

function isAuthError(err){
  if (!err) return false;
  if (err.status === 401 || err.status === 403) return true;
  const msg = String(err.message || err || '').toLowerCase();
  return msg.includes('401') || msg.includes('403') || msg.includes('unauthor');
}

function redirectToUnauthorized(params = {}){
  try {
    const path = (window.location.pathname || '').toLowerCase();
    if (path.endsWith('/unauthorized') || path.endsWith('/unauthorized.html')) {
      return true;
    }
  } catch (err) {}

  const targetParams = params && typeof params === 'object' ? params : {};
  let href = '/akuvox-ac/unauthorized';
  try {
    href = buildHref('unauthorized', targetParams);
  } catch (err) {
    try {
      const search = new URLSearchParams();
      Object.entries(targetParams).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== '') search.set(key, value);
      });
      const token = sessionStorage.getItem('akuvox_ll_token');
      if (token && !search.has('token')) search.set('token', token);
      const authSig = currentAuthSig();
      if (authSig && !search.has('authSig')) search.set('authSig', authSig);
      const query = search.toString();
      if (query) href = `/akuvox-ac/unauthorized?${query}`;
    } catch (err2) {}
  }

  let delivered = false;
  try {
    delivered = requestParentNav('unauthorized', targetParams, { replaceState: true });
  } catch (err) {}

  if (!delivered) {
    try { window.location.replace(href); }
    catch (err) { window.location.href = href; }
  }
  return true;
}

function handleAuthError(err){
  if (!isAuthError(err)) return false;
  redirectToUnauthorized();
  return true;
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_STATE           = signedPath('state', '/api/akuvox_ac/ui/state');
const API_PHONES          = signedPath('phones', '/api/akuvox_ac/ui/phones');
const API_RESERVE_ID      = signedPath('reserve_id', '/api/akuvox_ac/ui/reserve_id');
const API_RELEASE_ID      = signedPath('release_id', '/api/akuvox_ac/ui/release_id');
const API_RESERVATION_PING = signedPath('reservation_ping', '/api/akuvox_ac/ui/reservation_ping');
const API_UPLOAD_FACE     = signedPath('upload_face', '/api/akuvox_ac/ui/upload_face');
const API_REMOTE_ENROL    = signedPath('remote_enrol', '/api/akuvox_ac/ui/remote_enrol');
const API_EDIT_USER       = signedPath('service_edit_user', '/api/services/akuvox_ac/edit_user');

const DEFAULT_CREDENTIAL_PROMPTS = { code: true, token: true, anpr: false, face: true, phone: true };
let CREDENTIAL_PROMPTS = { ...DEFAULT_CREDENTIAL_PROMPTS };
let CONTACT_MODE = false;
const MAX_LICENSE_PLATES = 5;

async function apiGet(url){
  const r = await fetchWithAuth(url);
  if (!r.ok){
    const text = await r.text();
    const err = buildError(r, text);
    handleAuthError(err);
    throw err;
  }
  return r.json();
}
async function apiPost(url, body){
  const r = await fetchWithAuth(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body||{}) });
  if (!r.ok){
    const text = await r.text();
    const err = buildError(r, text);
    handleAuthError(err);
    throw err;
  }
  return r.json();
}
const UI_ROOT = '/akuvox-ac';
let BUSY = false;
function setBusy(yes){
  BUSY = !!yes;
  const busyEl = document.getElementById('busy');
  if (busyEl) busyEl.style.display = yes ? 'inline-block':'none';
  document.querySelectorAll('[data-busy-lock]').forEach(el => {
    if (yes){
      if (!el.dataset.busyPrevDisabled){
        el.dataset.busyPrevDisabled = el.disabled ? '1' : '0';
      }
      if ('disabled' in el) el.disabled = true;
    } else if (el.dataset.busyPrevDisabled) {
      if ('disabled' in el) el.disabled = el.dataset.busyPrevDisabled === '1';
      delete el.dataset.busyPrevDisabled;
    }
  });
}

function buildHref(slug, params = {}) {
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === undefined || value === null || value === '') return;
    search.set(key, value);
  });
  const token = sessionStorage.getItem('akuvox_ll_token');
  if (token) search.set('token', token);
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const clean = String(slug || '').replace(/_/g, '-');
  return `${UI_ROOT}/${clean}${query ? `?${query}` : ''}`;
}

function requestParentNav(view, params = {}, options = {}) {
  try {
    if (window.parent && window.parent !== window) {
      const msg = {
        type: 'akuvox-nav',
        view: String(view || ''),
        slug: String(view || ''),
        params
      };
      if (options.updateHistory === false) msg.updateHistory = false;
      if (options.replaceState) msg.replaceState = true;
      window.parent.postMessage(msg, window.location.origin);
      return true;
    }
  } catch (err) {}
  return false;
}

function openInApp(view, params = {}, options = {}) {
  const href = buildHref(view, params);
  const delivered = requestParentNav(view, params, options);
  if (!delivered) {
    window.location.href = href;
  }
  return delivered;
}

/* -------------------- app state -------------------- */
let SCHEDULES = {};     // { name: weekSpec, ... }
let PHONES = [];        // [{service, name}, ...] from /api/akuvox_ac/ui/phones
let REGISTRY = [];      // UI list of known users from /ui/state
let CURRENT = null;     // working user object
let RESERVED_ID = null; // HA### id reserved for new-user workflow
let ANY_ALARM_CAPABLE = true;

let reservationTimer = null;
let reservationMisses = 0;
let reservationHeartbeatBusy = false;

const RESERVATION_STORAGE_KEY = 'akuvox_ac_reserved_id';
const RESERVATION_STALE_AFTER = 15 * 60 * 1000; // 15 minutes

function parseReservationRecord(raw) {
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    const id = String(parsed.id || '').trim();
    if (!id) return null;
    const ts = Number(parsed.ts || 0);
    return { id, ts: Number.isFinite(ts) && ts > 0 ? ts : Date.now() };
  } catch (err) {
    return null;
  }
}

function rememberReservationId(id) {
  const clean = String(id || '').trim();
  if (!clean) {
    forgetReservationId();
    return;
  }
  try {
    if (typeof sessionStorage !== 'undefined') {
      sessionStorage.setItem(RESERVATION_STORAGE_KEY, JSON.stringify({ id: clean, ts: Date.now() }));
    }
  } catch (err) {}
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(RESERVATION_STORAGE_KEY, JSON.stringify({ id: clean, ts: Date.now() }));
    }
  } catch (err) {}
}

function forgetReservationId() {
  try {
    if (typeof sessionStorage !== 'undefined') {
      sessionStorage.removeItem(RESERVATION_STORAGE_KEY);
    }
  } catch (err) {}
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.removeItem(RESERVATION_STORAGE_KEY);
    }
  } catch (err) {}
}

function readStoredReservation() {
  const fromSession = (() => {
    try {
      if (typeof sessionStorage === 'undefined') return null;
      return parseReservationRecord(sessionStorage.getItem(RESERVATION_STORAGE_KEY));
    } catch (err) {
      return null;
    }
  })();
  if (fromSession) return fromSession;

  const fromLocal = (() => {
    try {
      if (typeof localStorage === 'undefined') return null;
      return parseReservationRecord(localStorage.getItem(RESERVATION_STORAGE_KEY));
    } catch (err) {
      return null;
    }
  })();
  if (!fromLocal) return null;

  try {
    if (typeof sessionStorage !== 'undefined') {
      const payload = JSON.stringify({ id: fromLocal.id, ts: fromLocal.ts || Date.now() });
      sessionStorage.setItem(RESERVATION_STORAGE_KEY, payload);
    }
  } catch (err) {}
  try {
    if (typeof localStorage !== 'undefined') {
      const payload = JSON.stringify({ id: fromLocal.id, ts: fromLocal.ts || Date.now() });
      localStorage.setItem(RESERVATION_STORAGE_KEY, payload);
    }
  } catch (err) {
    /* ignore */
  }
  return fromLocal;
}

function setReservationMessage(html, tone = 'muted') {
  const el = document.getElementById('localHelp');
  if (!el) return;
  if (!html) {
    el.innerHTML = '';
    return;
  }
  const cls = tone === 'error' ? 'text-danger' : tone === 'warning' ? 'text-warning' : 'muted';
  el.innerHTML = `<span class="${cls}">${html}</span>`;
}

function escapeHtml(value){
  return String(value ?? '').replace(/[&<>"']/g, (ch) => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  }[ch] || ch));
}

function updateKeyHolderAvailability(){
  const row = document.getElementById('keyHolderRow');
  const input = document.getElementById('key_holder');
  if (!row || !input) return;
  if (ANY_ALARM_CAPABLE && !CONTACT_MODE){
    row.style.display = '';
  } else {
    row.style.display = 'none';
    input.checked = false;
    if (CURRENT) CURRENT.key_holder = false;
  }
}

function stopReservationHeartbeat() {
  if (reservationTimer) {
    clearInterval(reservationTimer);
    reservationTimer = null;
  }
  reservationHeartbeatBusy = false;
  reservationMisses = 0;
}

async function heartbeatTick() {
  if (!RESERVED_ID || reservationHeartbeatBusy) return;
  reservationHeartbeatBusy = true;
  try {
    const res = await fetchWithAuth(API_RESERVATION_PING, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: RESERVED_ID })
    });
    if (!res.ok) throw new Error(await res.text());
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || 'ping failed');
    if (data.active === false) {
      setReservationMessage('Reserved ID expired. Requesting a new ID…', 'warning');
      RESERVED_ID = null;
      stopReservationHeartbeat();
      const newId = await reserveNewId({ showWarning: true });
      if (newId && CURRENT) CURRENT.id = newId;
      return;
    }
    reservationMisses = 0;
  } catch (err) {
    if (handleAuthError(err)) return;
    reservationMisses += 1;
    if (reservationMisses >= 6) {
      setReservationMessage('Connection lost. Releasing reserved ID and trying again…', 'warning');
      try { await releaseReservation({ keepalive: true }); } catch (e) {}
      RESERVED_ID = null;
      stopReservationHeartbeat();
      const newId = await reserveNewId({ showWarning: true });
      if (newId && CURRENT) CURRENT.id = newId;
    }
  } finally {
    reservationHeartbeatBusy = false;
  }
}

function startReservationHeartbeat() {
  stopReservationHeartbeat();
  if (!RESERVED_ID) return;
  reservationTimer = setInterval(heartbeatTick, 10000);
}

function applyReservedIdToForm(id) {
  const clean = String(id || '').trim();
  stopReservationHeartbeat();
  RESERVED_ID = clean ? clean : null;
  const idRow = document.getElementById('idRow');
  const input = document.getElementById('user_id');
  if (input) input.value = clean;
  if (idRow) idRow.style.display = clean ? 'block' : 'none';
  if (clean) {
    rememberReservationId(clean);
    setReservationMessage('');
    startReservationHeartbeat();
  } else {
    forgetReservationId();
  }
}

async function restoreReservationFromStorage() {
  const stored = readStoredReservation();
  if (!stored) return '';
  const id = String(stored.id || '').trim();
  if (!id) return '';

  const ts = Number(stored.ts || 0);
  if (Number.isFinite(ts) && ts > 0) {
    const age = Date.now() - ts;
    if (age > RESERVATION_STALE_AFTER) {
      forgetReservationId();
      return '';
    }
  }

  applyReservedIdToForm(id);
  return id;
}

async function reserveNewId(options = {}) {
  applyReservedIdToForm('');
  try {
    const res = await apiGet(API_RESERVE_ID);
    const newId = res && res.ok && res.id ? res.id : '';
    if (!newId) throw new Error('reserve failed');
    applyReservedIdToForm(newId);
    return newId;
  } catch (err) {
    applyReservedIdToForm('');
    if (handleAuthError(err)) return '';
    if (options.showWarning !== false) {
      setReservationMessage('ID reserve failed. You can still press <b>Save</b> to create a user, then return to upload a face.', 'warning');
    }
    return '';
  }
}

function selectExistingUser(id, options = {}){
  const targetId = String(id || '').trim();
  if (!targetId) return;
  const candidates = Array.isArray(REGISTRY) ? REGISTRY : [];
  const existing = candidates.find(u => String(u.id || u.UserID || u.UserId || u.ID || '').trim() === targetId);
  if (!existing) {
    alert('Unable to find that user in Home Assistant.');
    return;
  }

  CURRENT = {
    ...blankProfile(existing.id || targetId),
    ...existing,
    groups: Array.isArray(existing.groups)
      ? [...existing.groups]
      : Array.isArray(existing.Groups)
      ? [...existing.Groups]
      : ['Default'],
  };
  CURRENT.license_plate = sanitizeLicensePlateList(existing.license_plate || existing.LicensePlate || CURRENT.license_plate);
  if (!CURRENT.schedule_id && CURRENT.schedule_name) {
    CURRENT.schedule_id = idForName(CURRENT.schedule_name);
  }

  RESERVED_ID = null;
  stopReservationHeartbeat();
  setReservationMessage('');
  forgetReservationId();

  const idRow = document.getElementById('idRow');
  if (idRow) idRow.style.display = 'block';
  const idInput = document.getElementById('user_id');
  if (idInput) idInput.value = CURRENT.id || targetId;
  document.getElementById('title').textContent = CONTACT_MODE ? 'Edit Contact' : 'Edit User';

  fillForm();
  fillPhones();
  updateKeyHolderAvailability();

  if (options?.updateUrl !== false) {
    try {
      const url = new URL(location.href);
      url.searchParams.set('id', CURRENT.id || targetId);
      if (CONTACT_MODE) url.searchParams.set('mode', 'contact');
      else url.searchParams.delete('mode');
      history.replaceState(history.state || {}, '', url);
    } catch (err) {}
  }

  const nameInput = document.getElementById('name');
  if (nameInput) nameInput.focus();
}

// ---------- schedule id mapping helpers ----------
let SCHED_MAP = []; // [{id:"1001", name:"24/7 Access", label:"24/7 Access", display:"HA1 - 24/7 Access"}, ...]

function scheduleDisplayId(rawId){
  const text = String(rawId ?? '').trim();
  if (!/^\d+$/.test(text)) return '';
  const numeric = Number(text);
  if (!Number.isFinite(numeric) || numeric <= 0) return '';
  const suffix = numeric >= 1000 ? numeric - 1000 : numeric;
  if (suffix <= 0) return '';
  return `HA${suffix}`;
}

function formatScheduleDisplay(rawId, label){
  const name = String(label ?? '').trim();
  const displayId = scheduleDisplayId(rawId);
  if (displayId && name) return `${displayId} - ${name}`;
  return displayId || name;
}

function todayIso(){
  const now = new Date();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  return `${now.getFullYear()}-${month}-${day}`;
}

function parseIsoDate(value){
  const text = String(value || '').trim();
  if (!text) return null;
  const match = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(text);
  if (!match) return null;
  const year = Number(match[1]);
  const month = Number(match[2]);
  const day = Number(match[3]);
  const candidate = new Date(year, month - 1, day);
  if (
    Number.isNaN(candidate.getTime())
    || candidate.getFullYear() !== year
    || candidate.getMonth() !== month - 1
    || candidate.getDate() !== day
  ){
    return null;
  }
  return candidate;
}

function computeAccessState(startStr, endStr){
  const startDate = parseIsoDate(startStr);
  const endDate = parseIsoDate(endStr);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  return {
    startDate,
    endDate,
    expired: !!(endDate && endDate <= today),
    notStarted: !!(startDate && startDate > today)
  };
}

function blankProfile(id = ''){
  return {
    id,
    name: '',
    groups: ['Default'],
    pin: '',
    phone: '',
    license_plate: [],
    schedule_name: '24/7 Access',
    schedule_id: '1001',
    key_holder: false,
    access_level: '',
    access_start: todayIso(),
    access_end: '',
    access_expired: false,
    access_in_future: false,
  };
}

function sanitizeCredentialPrompts(raw){
  const base = { ...DEFAULT_CREDENTIAL_PROMPTS };
  if (!raw || typeof raw !== 'object') return base;
  Object.keys(DEFAULT_CREDENTIAL_PROMPTS).forEach((key) => {
    if (typeof raw[key] === 'boolean') base[key] = raw[key];
  });
  if (typeof raw.phone !== 'boolean' && typeof raw.token === 'boolean') {
    base.phone = raw.token;
  }
  return base;
}

function sanitizeLicensePlateList(raw){
  const array = Array.isArray(raw) ? raw : [];
  const cleaned = [];
  const seen = new Set();
  for (const entry of array){
    let text = '';
    if (typeof entry === 'string'){ text = entry.trim(); }
    else if (entry && typeof entry === 'object'){
      text = String(entry.Plate || entry.plate || entry.value || entry.Value || '').trim();
    }
    if (!text) continue;
    const normalized = text.toUpperCase();
    if (seen.has(normalized)) continue;
    seen.add(normalized);
    cleaned.push(normalized);
    if (cleaned.length >= MAX_LICENSE_PLATES) break;
  }
  return cleaned;
}

function collectLicensePlates(){
  const container = document.getElementById('licensePlateList');
  const values = [];
  if (container){
    container.querySelectorAll('input[data-plate-index]').forEach(input => {
      values.push((input.value || '').trim());
    });
  } else if (Array.isArray(CURRENT?.license_plate)){
    values.push(...CURRENT.license_plate);
  }
  return sanitizeLicensePlateList(values);
}

function renderLicensePlateInputs(focusIndex){
  const container = document.getElementById('licensePlateList');
  if (!container || !CURRENT) return;
  if (CONTACT_MODE) {
    container.innerHTML = '';
    return;
  }
  if (!Array.isArray(CURRENT.license_plate)) CURRENT.license_plate = [];
  CURRENT.license_plate = CURRENT.license_plate.slice(0, MAX_LICENSE_PLATES);
  container.innerHTML = '';
  const plates = CURRENT.license_plate;
  if (!plates.length){
    const empty = document.createElement('div');
    empty.className = 'muted small';
    empty.textContent = 'No license plates assigned.';
    container.appendChild(empty);
  } else {
    plates.forEach((value, index) => {
      const row = document.createElement('div');
      row.className = 'input-group mb-2 license-plate-row';
      const input = document.createElement('input');
      input.className = 'form-control license-plate-input';
      input.placeholder = 'e.g. ABC123';
      input.value = value || '';
      input.setAttribute('data-plate-index', index);
      input.addEventListener('input', (ev) => {
        CURRENT.license_plate[index] = ev.target.value;
      });
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-outline-danger';
      btn.innerHTML = '<i class="bi bi-trash"></i>';
      btn.addEventListener('click', () => {
        CURRENT.license_plate.splice(index, 1);
        renderLicensePlateInputs();
      });
      row.appendChild(input);
      row.appendChild(btn);
      container.appendChild(row);
    });
  }
  const addBtn = document.getElementById('addLicensePlateBtn');
  if (addBtn){
    addBtn.disabled = !CREDENTIAL_PROMPTS.anpr || CURRENT.license_plate.length >= MAX_LICENSE_PLATES;
    addBtn.onclick = () => {
      if (!CREDENTIAL_PROMPTS.anpr) return;
      if (!Array.isArray(CURRENT.license_plate)) CURRENT.license_plate = [];
      if (CURRENT.license_plate.length >= MAX_LICENSE_PLATES) return;
      CURRENT.license_plate.push('');
      renderLicensePlateInputs(CURRENT.license_plate.length - 1);
    };
  }
  if (typeof focusIndex === 'number'){
    requestAnimationFrame(() => {
      const focusInput = container.querySelector(`input[data-plate-index="${focusIndex}"]`);
      if (focusInput){
        focusInput.focus();
        focusInput.select();
      }
    });
  }
}

function applyCredentialPrompts(){
  CREDENTIAL_PROMPTS = sanitizeCredentialPrompts(CREDENTIAL_PROMPTS);
  const pinRow = document.getElementById('pinRow');
  if (pinRow){
    pinRow.style.display = CONTACT_MODE ? 'none' : (CREDENTIAL_PROMPTS.code ? '' : 'none');
  }
  const phoneRow = document.getElementById('phoneRow');
  if (phoneRow){
    phoneRow.style.display = CREDENTIAL_PROMPTS.phone ? '' : 'none';
  }
  const faceSection = document.getElementById('faceSection');
  if (faceSection){
    faceSection.style.display = CONTACT_MODE ? 'none' : (CREDENTIAL_PROMPTS.face ? '' : 'none');
  }
  if (!CREDENTIAL_PROMPTS.face || CONTACT_MODE){
    const local = document.getElementById('pLocal');
    const remote = document.getElementById('pRemote');
    if (local) local.style.display = 'none';
    if (remote) remote.style.display = 'none';
  }
  const anprSection = document.getElementById('anprSection');
  if (anprSection){
    anprSection.style.display = CONTACT_MODE ? 'none' : (CREDENTIAL_PROMPTS.anpr ? '' : 'none');
    if (!CONTACT_MODE) {
      renderLicensePlateInputs();
    }
  }
}

function applyContactMode(){
  if (!CONTACT_MODE) return;
  const title = document.getElementById('title');
  if (title) title.textContent = CURRENT && CURRENT.id ? 'Edit Contact' : 'Add Contact';
  const scheduleRow = document.getElementById('scheduleRow');
  if (scheduleRow) scheduleRow.style.display = 'none';
  const scheduleSelect = document.getElementById('schedule');
  if (scheduleSelect && CURRENT) {
    const target = CURRENT.schedule_id || '1002';
    scheduleSelect.value = target;
    CURRENT.schedule_id = target;
    CURRENT.schedule_name = nameForId(target);
  }
  const accessBlock = document.getElementById('accessWindow');
  if (accessBlock) accessBlock.style.display = 'none';
  const reactivateRow = document.getElementById('accessReactivateRow');
  if (reactivateRow) reactivateRow.style.display = 'none';
  const expiryNotice = document.getElementById('accessExpiryNotice');
  if (expiryNotice) expiryNotice.style.display = 'none';
  const licenseList = document.getElementById('licensePlateList');
  if (licenseList) licenseList.innerHTML = '';
}

function buildScheduleMap(){
  // Built-ins first
  const out = [
    { id: '1001', name: '24/7 Access', label: '24/7 Access' },
    { id: '1002', name: 'No Access',   label: 'No Access' }
  ];
  // Custom schedules (deterministic IDs: 1003+)
  const customNames = Object.keys(SCHEDULES || {})
    .filter(n => n !== '24/7 Access' && n !== 'No Access')
    .sort((a,b) => a.localeCompare(b));
  const base = 1003;
  customNames.forEach((name, i) => {
    const id = String(base + i);
    out.push({ id, name, label: name });
  });
  SCHED_MAP = out.map(item => ({ ...item, display: formatScheduleDisplay(item.id, item.label) }));
}
function optionLabel(item){
  const display = item && typeof item === 'object'
    ? (item.display || formatScheduleDisplay(item.id, item.label))
    : '';
  return display || `${item.id} - ${item.label}`;
}
function nameForId(id){
  const x = SCHED_MAP.find(s => s.id === String(id));
  return x ? x.name : '24/7 Access';
}
function idForName(name){
  const lower = String(name || '').toLowerCase();
  if (lower === '24/7 access' || lower === '24/7') return '1001';
  if (lower === 'no access' || lower === 'never')  return '1002';
  const x = SCHED_MAP.find(s => s.name.toLowerCase() === lower);
  return x ? x.id : '1001';
}

async function releaseReservation(options = {}){
  const explicit = Object.prototype.hasOwnProperty.call(options || {}, 'id')
    ? String(options.id || '').trim()
    : '';
  const id = explicit || RESERVED_ID;
  if (!id) return;

  const releasingActive = !explicit || explicit === RESERVED_ID;
  if (releasingActive) {
    applyReservedIdToForm('');
  }

  const payload = JSON.stringify({ id });
  if (options.keepalive && navigator.sendBeacon) {
    try {
      const blob = new Blob([payload], { type: 'application/json' });
      const ok = navigator.sendBeacon(API_RELEASE_ID, blob);
      if (ok) return;
    } catch (err) {}
  }
  try {
    await fetchWithAuth(API_RELEASE_ID, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: payload,
      keepalive: !!options.keepalive
    });
  } catch (err) {}
}

window.addEventListener('beforeunload', () => {
  if (RESERVED_ID) {
    stopReservationHeartbeat();
    releaseReservation({ keepalive: true });
  }
});

/* -------------------- load -------------------- */
async function load(){
  setBusy(true);
  try{
    let state;
    try {
      state = await apiGet(API_STATE);
    } catch (err) {
      if (handleAuthError(err)) return;
      console.warn('Failed to load Akuvox state', err);
      alert('Failed to load Akuvox data. Default values will be used until the connection succeeds.');
      state = { schedules: {}, registry_users: [] };
    }
    ANY_ALARM_CAPABLE = false;
    if (state && typeof state === 'object'){
      const caps = state.capabilities;
      if (caps && typeof caps === 'object' && typeof caps.alarm_relay === 'boolean'){
        ANY_ALARM_CAPABLE = caps.alarm_relay;
      }
      if (!ANY_ALARM_CAPABLE && Array.isArray(state.devices)){
        ANY_ALARM_CAPABLE = state.devices.some(dev => {
          if (!dev || typeof dev !== 'object') return false;
          const roles = dev.relay_roles || {};
          const norm = (val) => String(val ?? '').toLowerCase().replace(/[\s-]+/g, '_');
          const a = norm(roles.relay_a);
          const b = norm(roles.relay_b);
          return a === 'alarm' || a === 'door_alarm' || b === 'alarm' || b === 'door_alarm';
        });
      }
    }
    updateKeyHolderAvailability();
    CREDENTIAL_PROMPTS = sanitizeCredentialPrompts(state?.credential_prompts);
    SCHEDULES = state.schedules || {};
    REGISTRY = state.registry_users || [];

    // Load phones (notify services from HA mobile app)
    try {
      const resp = await apiGet(API_PHONES);
      PHONES = resp.phones || [];
    } catch (err) {
      if (handleAuthError(err)) return;
      console.warn('Failed to load phone list', err);
      PHONES = [];
    }

    const params = new URLSearchParams(location.search);
    const id = (params.get('id') || '').trim();
    const modeParam = (params.get('mode') || '').toLowerCase();
    const phonePromptEnabled = !!CREDENTIAL_PROMPTS.phone;
    CONTACT_MODE = phonePromptEnabled && modeParam === 'contact';
    const startInEditMode = modeParam === 'edit';
    if (CONTACT_MODE) {
      CREDENTIAL_PROMPTS = sanitizeCredentialPrompts({
        ...CREDENTIAL_PROMPTS,
        code: false,
        token: false,
        face: false,
        anpr: false,
        phone: true,
      });
    }
    let handledBySelect = false;

    if (id) {
      const hasMatch = (REGISTRY || []).some(u => String(u.id || u.UserID || u.UserId || u.ID || '') === id);
      if (hasMatch) {
        selectExistingUser(id, { updateUrl: false });
        handledBySelect = true;
      } else {
        CURRENT = blankProfile(id);
        RESERVED_ID = null;
        stopReservationHeartbeat();
        setReservationMessage('');
        forgetReservationId();
        document.getElementById('title').textContent = CONTACT_MODE ? 'Edit Contact' : 'Edit User';
        document.getElementById('idRow').style.display = 'block';
        document.getElementById('user_id').value = CURRENT.id;
      }
    } else if (!startInEditMode) {
      document.getElementById('title').textContent = CONTACT_MODE ? 'Add Contact' : 'Add User';
      CURRENT = blankProfile('');
      const restoredId = await restoreReservationFromStorage();
      if (restoredId) {
        CURRENT.id = restoredId;
        if (!CURRENT.schedule_id) CURRENT.schedule_id = '1001';
      } else {
        const newId = await reserveNewId();
        if (newId) {
          CURRENT.id = newId;
          CURRENT.schedule_id = '1001';
        } else {
          const idRow = document.getElementById('idRow');
          if (idRow) idRow.style.display = 'none';
        }
      }
      if (CONTACT_MODE) {
        CURRENT.schedule_id = '1002';
        CURRENT.schedule_name = 'No Access';
        CURRENT.access_start = todayIso();
        CURRENT.access_end = '';
        CURRENT.access_expired = false;
        CURRENT.access_in_future = false;
        CURRENT.key_holder = false;
      }
    } else {
      CURRENT = blankProfile('');
      applyReservedIdToForm('');
      setReservationMessage('');
      document.getElementById('title').textContent = CONTACT_MODE ? 'Edit Contact' : 'Edit User';
      const idRow = document.getElementById('idRow');
      if (idRow) idRow.style.display = 'none';
    }

    if (!handledBySelect) {
      fillForm();
      fillPhones();
    }
  } finally {
    setBusy(false);
  }
}

function scheduleOptionsHtml(){
  buildScheduleMap();
  return SCHED_MAP.map(it => `<option value="${it.id}">${optionLabel(it)}</option>`).join('');
}

function fillForm(){
  document.getElementById('name').value = CURRENT.name || '';
  document.getElementById('pin').value = CURRENT.pin || '';
  document.getElementById('phone').value = CURRENT.phone || '';
  CURRENT.license_plate = Array.isArray(CURRENT.license_plate) ? [...CURRENT.license_plate] : [];
  renderLicensePlateInputs();

  // Build schedule select with ids
  document.getElementById('schedule').innerHTML = scheduleOptionsHtml();
  const selEl = document.getElementById('schedule');
  const ids = new Set(Array.from(selEl.options).map(opt => opt.value));
  let selectedId = CURRENT.schedule_id ? String(CURRENT.schedule_id) : '';
  if (!selectedId || !ids.has(selectedId)) {
    selectedId = idForName(CURRENT.schedule_name || '24/7 Access');
  }
  if (!ids.has(selectedId)) {
    selectedId = '1001';
  }
  selEl.value = selectedId;
  CURRENT.schedule_id = selectedId;
  CURRENT.schedule_name = nameForId(selectedId);

  const startInput = document.getElementById('access_start');
  if (startInput){
    const normalizedStart = (CURRENT.access_start && String(CURRENT.access_start).trim())
      ? String(CURRENT.access_start).trim()
      : todayIso();
    startInput.value = normalizedStart;
    CURRENT.access_start = normalizedStart;
    if (!startInput._expiryBound){
      const handler = () => updateAccessExpirationUI();
      startInput.addEventListener('change', handler);
      startInput.addEventListener('input', handler);
      startInput._expiryBound = true;
    }
  }

  const endInput = document.getElementById('access_end');
  if (endInput){
    const normalizedEnd = (CURRENT.access_end && String(CURRENT.access_end).trim())
      ? String(CURRENT.access_end).trim()
      : '';
    endInput.value = normalizedEnd;
    CURRENT.access_end = normalizedEnd;
    if (!endInput._expiryBound){
      const handler = () => updateAccessExpirationUI();
      endInput.addEventListener('change', handler);
      endInput.addEventListener('input', handler);
      endInput._expiryBound = true;
    }
  }

  updateAccessExpirationUI();

  const keyInput = document.getElementById('key_holder');
  if (keyInput){
    keyInput.checked = ANY_ALARM_CAPABLE && !!CURRENT.key_holder;
  }
  updateKeyHolderAvailability();

  const localHelp = document.getElementById('localHelp');
  if (localHelp && !localHelp.innerHTML){
    if (CURRENT.id){
      localHelp.innerHTML = `<span class="muted">If you select a photo, it will be saved as <code>/api/AK_AC/FaceData/${CURRENT.id}.jpg</code> when you press <b>Save</b>.</span>`;
    } else {
      localHelp.innerHTML = `<span class="muted">ID reserve failed. You can still press <b>Save</b> to create a user, then return to upload a face.</span>`;
    }
  }
  applyCredentialPrompts();
  applyContactMode();
}

function updateAccessExpirationUI(){
  const startInput = document.getElementById('access_start');
  const endInput = document.getElementById('access_end');
  const notice = document.getElementById('accessExpiryNotice');
  const reactivateRow = document.getElementById('accessReactivateRow');
  if (!startInput || !endInput) return;

  const startVal = String(startInput.value || '').trim();
  const endVal = String(endInput.value || '').trim();
  const state = computeAccessState(startVal, endVal);

  if (CURRENT){
    CURRENT.access_start = startVal || '';
    CURRENT.access_end = endVal || '';
    CURRENT.access_expired = !!state.expired;
    CURRENT.access_in_future = !!state.notStarted;
  }

  if (state.expired){
    if (notice){
      const label = state.endDate ? state.endDate.toISOString().slice(0, 10) : '';
      notice.textContent = label ? `Access expired on ${label}.` : 'Access expired.';
      notice.className = 'mb-2 fw-semibold text-danger';
      notice.style.display = '';
    }
    if (reactivateRow){
      reactivateRow.style.display = 'flex';
    }
    return;
  }

  if (state.notStarted){
    if (notice){
      const label = state.startDate ? state.startDate.toISOString().slice(0, 10) : '';
      notice.textContent = label ? `Access starts on ${label}.` : 'Access not yet active.';
      notice.className = 'mb-2 fw-semibold text-warning';
      notice.style.display = '';
    }
    if (reactivateRow){
      reactivateRow.style.display = 'none';
    }
    return;
  }

  if (notice){
    notice.style.display = 'none';
  }
  if (reactivateRow){
    reactivateRow.style.display = 'none';
  }
}

function reactivateAccess(evt){
  if (evt) evt.preventDefault();
  const startInput = document.getElementById('access_start');
  const endInput = document.getElementById('access_end');
  if (startInput){
    startInput.value = todayIso();
  }
  if (endInput){
    endInput.value = '';
  }
  updateAccessExpirationUI();
  if (startInput){
    startInput.focus();
  }
}

// Populate the Remote Enrolment dropdown with HA phone notify services
function fillPhones(){
  const sel = document.getElementById('device');  // keeping id=device for layout compatibility
  sel.innerHTML = '';
  if (!PHONES.length){
    sel.innerHTML = `<option value="" disabled selected>(no phones found)</option>`;
    sel.disabled = true;
  }else{
    sel.disabled = false;
    const sorted = [...PHONES].sort((a,b) => (a.name || a.service || '').localeCompare(b.name || b.service || ''));
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select phone…';
    placeholder.disabled = true;
    placeholder.selected = true;
    sel.appendChild(placeholder);
    sorted.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.service;            // e.g. "mobile_app_johns_iphone"
      opt.textContent = p.name || p.service;
      sel.appendChild(opt);
    });
  }
  const resSpan = document.getElementById('remoteResult');
  if (resSpan) resSpan.textContent = '';
}

/* -------------------- save: user core + optional face upload + optional remote enrol -------------------- */
async function save(){
  if (!CURRENT){
    alert('Form not ready yet. Please reload the page.');
    return;
  }
  if (BUSY) return;
  setBusy(true);
  try{
    // Ensure we have or reserve an ID
    if (!CURRENT.id){
      try{
        const res = await apiGet(API_RESERVE_ID);
        if (res && res.ok && res.id) {
          CURRENT.id = res.id;
          RESERVED_ID = CURRENT.id;
          document.getElementById('idRow').style.display = 'block';
          document.getElementById('user_id').value = CURRENT.id;
        }
      }catch(err){
        if (handleAuthError(err)) return;
      }
      if (!CURRENT.id){
        alert('Could not reserve a user ID. Please try again.');
        return;
      }
    }

    const scheduleEl = document.getElementById('schedule');
    let selectedScheduleId = CONTACT_MODE ? '1002' : (scheduleEl && scheduleEl.value ? scheduleEl.value : '1001');
    let selectedScheduleName = nameForId(selectedScheduleId);
    if (CONTACT_MODE) {
      selectedScheduleName = 'No Access';
    }

    const prompts = sanitizeCredentialPrompts(CREDENTIAL_PROMPTS);
    const payload = {
      name: document.getElementById('name').value.trim(),
      groups: CURRENT.groups || ['Default'],
      schedule_id: selectedScheduleId,          // drives ScheduleRelay on backend
      schedule_name: selectedScheduleName,      // for UI/state clarity
      key_holder: ANY_ALARM_CAPABLE ? document.getElementById('key_holder').checked : false,
    };

    if (prompts.code){
      const pinValue = document.getElementById('pin').value.trim();
      payload.pin = pinValue || undefined;
      CURRENT.pin = pinValue;
    }

    const phoneInput = document.getElementById('phone');
    const phoneValue = phoneInput ? phoneInput.value.trim() : '';
    const hadPhone = !!(CURRENT && typeof CURRENT.phone === 'string' && CURRENT.phone.trim());
    if (prompts.phone || CONTACT_MODE || phoneValue || hadPhone){
      payload.phone = phoneValue;
      CURRENT.phone = phoneValue;
    }

    if (prompts.anpr && !CONTACT_MODE){
      const plates = collectLicensePlates();
      payload.license_plate = plates;
      CURRENT.license_plate = [...plates];
    }

    const accessStartInput = document.getElementById('access_start');
    const accessEndInput = document.getElementById('access_end');
    const accessStartVal = accessStartInput ? accessStartInput.value.trim() : '';
    const accessEndVal = accessEndInput ? accessEndInput.value.trim() : '';
    payload.access_start = accessStartVal || '';
    payload.access_end = accessEndVal || '';
    CURRENT.access_start = payload.access_start;
    CURRENT.access_end = payload.access_end;

    // Save/update the profile against the reserved ID
    const saveRes = await fetchWithAuth(API_EDIT_USER, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ id: CURRENT.id, ...payload })
    });
    if (!saveRes.ok){
      const txt = await saveRes.text();
      const err = buildError(saveRes, txt);
      handleAuthError(err);
      throw err;
    }
    try { await saveRes.json(); } catch {}

    // If a photo is selected, upload it now
    const fileInput = document.getElementById('facefile');
    if (fileInput.files && fileInput.files[0]){
      const fd = new FormData();
      fd.append('id', CURRENT.id);
      fd.append('file', fileInput.files[0]);
      const r = await fetchWithAuth(API_UPLOAD_FACE, {
        method: 'POST',
        body: fd
      });
      if (!r.ok){
        const t = await r.text();
        const err = buildError(r, t);
        handleAuthError(err);
        throw err;
      }
      try { await r.json(); } catch {}
    }

    // If Remote panel is visible and a phone is selected, auto-send enrolment request now
    const remoteVisible = document.getElementById('pRemote').style.display !== 'none';
    const phoneSel = document.getElementById('device');
    const phoneService = phoneSel && phoneSel.value ? phoneSel.value : '';
    if (remoteVisible && phoneService){
      try{
        await apiPost(API_REMOTE_ENROL, {
          id: CURRENT.id,
          phone_service: phoneService,
          name: document.getElementById('name').value.trim()
        });
        const resSpan = document.getElementById('remoteResult');
        if (resSpan) resSpan.textContent = 'Enrolment request sent.';
      }catch(e){
        if (handleAuthError(e)) return;
        const resSpan = document.getElementById('remoteResult');
        if (resSpan) resSpan.textContent = 'Failed to send enrolment request.';
      }
    }

    // Back to list
    stopReservationHeartbeat();
    forgetReservationId();
    RESERVED_ID = null;
    openInApp('index', { section: 'users' }, { replaceState: true });
  } catch (e){
    if (handleAuthError(e)) return;
    alert('Save failed: ' + (e && e.message ? e.message : e));
  } finally {
    setBusy(false);
  }
}

/* -------------------- toggle panels -------------------- */
async function cancelEdit(evt){
  if (evt) evt.preventDefault();
  stopReservationHeartbeat();
  await releaseReservation();
  openInApp('index', { section: 'users' }, { replaceState: true });
}

function showPanel(which){
  document.getElementById('pLocal').style.display = which === 'local' ? 'block':'none';
  document.getElementById('pRemote').style.display = which === 'remote' ? 'block':'none';
}
</script>

<div class="container py-3 container-narrow">
  <div class="d-flex align-items-center gap-2">
    <h2 id="title" class="m-0">User</h2>
    <span id="busy" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display:none;"></span>
  </div>

  <div class="card p-3 mt-3">
    <div id="idRow" class="mb-3" style="display:none;">
      <label class="form-label">User ID</label>
      <input id="user_id" class="form-control" readonly />
      <div class="form-text muted">ID is reserved locally so your selected photo can upload when you press <b>Save</b>.</div>
    </div>

    <div class="mb-3"><label class="form-label">Name</label><input id="name" class="form-control"/></div>

    <div class="mb-3" id="pinRow">
      <label class="form-label">PIN</label>
      <div class="input-group">
        <input id="pin" class="form-control"/>
        <button class="btn btn-outline-secondary" onclick="document.getElementById('pin').value = String(Math.floor(1000+Math.random()*9000))">Random</button>
      </div>
    </div>

    <div class="mb-3" id="faceSection">
      <label class="form-label">Face Recognition</label>
      <div class="face-options mb-2">
        <button class="btn btn-outline-light btn-toggle" onclick="showPanel('local')"><i class="bi bi-upload me-1"></i>Local enrolment</button>
        <button class="btn btn-outline-light btn-toggle" onclick="showPanel('remote')"><i class="bi bi-wifi me-1"></i>Remote enrolment</button>
      </div>
    </div>

    <!-- Local enrolment panel -->
    <div id="pLocal" class="mt-2" style="display:none;">
      <div class="mb-2" id="localHelp"></div>
      <div class="mb-2">
        <input id="facefile" class="form-control" type="file" accept=".jpg,image/jpeg" />
        <div class="uploader-hint mt-1">Choose a clear, front-facing JPG photo. It will be uploaded when you press <b>Save</b>.</div>
      </div>
    </div>

    <!-- Remote enrolment panel -->
    <div id="pRemote" class="mt-2" style="display:none;">
      <div class="mb-2 muted">Choose a phone (Home Assistant app) to receive an enrolment prompt:</div>
      <div class="row g-2 align-items-end">
        <div class="col-sm-6">
          <label class="form-label">Phone</label>
          <select id="device" class="form-select"></select>
        </div>
      </div>
      <div class="mt-2 muted" id="remoteResult"></div>
    </div>

    <div class="mb-3" id="phoneRow"><label class="form-label">Phone number</label><input id="phone" class="form-control"/></div>

    <div class="mb-3" id="anprSection">
      <label class="form-label">License Plates (ANPR)</label>
      <div id="licensePlateList"></div>
      <button type="button" class="btn btn-outline-light btn-sm mt-2" id="addLicensePlateBtn"><i class="bi bi-plus-lg me-1"></i>Add plate</button>
      <div class="form-text muted">Enter up to five vehicle plates.</div>
    </div>

    <div class="mb-3" id="scheduleRow">
      <label class="form-label">Access Schedule</label>
      <select id="schedule" class="form-select"></select>
      <div class="form-text muted">Need a new schedule? Open <b>Global Settings → Access Schedules</b> to build one, then come back and select it here.</div>
    </div>

    <div class="mb-3" id="accessWindow">
      <div id="accessReactivateRow" class="mb-2" style="display:none;">
        <button type="button" class="btn btn-outline-success btn-sm" onclick="reactivateAccess(event)"><i class="bi bi-arrow-counterclockwise me-1"></i>Reactivate access</button>
      </div>
      <div id="accessExpiryNotice" class="mb-2 fw-semibold text-danger" style="display:none;"></div>
      <div class="row g-2">
        <div class="col-md-6">
          <label class="form-label">Access Start</label>
          <input id="access_start" type="date" class="form-control" />
        </div>
        <div class="col-md-6">
          <label class="form-label">Access End</label>
          <input id="access_end" type="date" class="form-control" />
        </div>
      </div>
      <div class="form-text muted mt-2">The start date defaults to today. Leave the end date empty to keep the user active indefinitely.</div>
    </div>

    <div class="form-check mb-3" id="keyHolderRow">
      <input class="form-check-input" type="checkbox" id="key_holder">
      <label class="form-check-label" for="key_holder">Key Holder (Disarm alarm and permit entry)</label>
    </div>

    <div class="action-buttons mb-3">
      <button class="btn btn-success" onclick="save()" data-busy-lock><i class="bi bi-check2-circle me-1"></i>Save</button>
      <a class="btn btn-secondary" href="#" onclick="cancelEdit(event)"><i class="bi bi-x-circle me-1"></i>Cancel</a>
    </div>

  </div>
</div>
<script>load()</script>
</body>
</html>
