<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Akuvox Global Settings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" crossorigin="anonymous" />
  <style>
    :root{ --bg:#0b1320; --card:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc; }
    body{ background:var(--bg); color:var(--text); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .card{ background:#111a2b; border:1px solid #1b2942; }
    label{ color:#fff; }
    .muted{ color:var(--muted); }
    .small-mono{ font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .saved-input-wrap{ position:relative; max-width:220px; width:100%; }
    .saved-input-wrap input{ width:100%; }
    .saved-overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:0.375rem;
      background:rgba(25,135,84,0.85);
      color:#fff;
      font-weight:600;
      letter-spacing:0.05em;
      text-transform:uppercase;
      pointer-events:none;
      opacity:0;
      transition:opacity 0.2s ease-in-out;
    }
    .saved-overlay.visible{ opacity:1; }
  </style>
</head>
<body>
<script>
(function () {
  const qs = new URLSearchParams(location.search);
  const qsToken = qs.get('token');
  if (qsToken) sessionStorage.setItem('akuvox_ll_token', qsToken);
})();
function findHaToken(){
  const existing = sessionStorage.getItem('akuvox_ll_token');
  if (existing) return existing;

  const scan = (stor) => {
    if (!stor) return null;
    try {
      const direct = stor.getItem('hassTokens');
      if (direct) {
        const parsed = JSON.parse(direct);
        const token = parsed?.access_token || parsed?.token?.access_token || parsed?.data?.access_token;
        if (token) return token;
      }
      for (const key of Object.keys(stor)) {
        if (!/auth|token|hass/i.test(key)) continue;
        try {
          const candidate = JSON.parse(stor.getItem(key));
          const token = candidate?.access_token || candidate?.token?.access_token || candidate?.data?.access_token;
          if (token) return token;
        } catch (err) {}
      }
    } catch (err) {}
    return null;
  };

  let token = scan(sessionStorage) || scan(localStorage);
  if (token) {
    sessionStorage.setItem('akuvox_ll_token', token);
    return token;
  }

  try {
    if (window.parent && window.parent !== window && window.parent.origin === window.origin) {
      token = scan(window.parent.sessionStorage) || scan(window.parent.localStorage);
      if (token) {
        sessionStorage.setItem('akuvox_ll_token', token);
        return token;
      }
    }
  } catch (err) {}

  return null;
}
const SAME_ORIGIN = { credentials: 'same-origin' };
const REJECTED_TOKENS = new Set();

function nextBearerToken(){
  const token = findHaToken();
  if (!token) return null;
  if (REJECTED_TOKENS.has(token)) return null;
  return token;
}

async function fetchWithAuth(url, options = {}, { allowRetry = true } = {}){
  const originalHeaders = { ...(options.headers || {}) };
  let bearer = allowRetry ? nextBearerToken() : null;
  let usedBearer = !!bearer;
  const headers = { ...originalHeaders };
  if (bearer) headers['Authorization'] = 'Bearer ' + bearer;

  const response = await fetch(url, { ...SAME_ORIGIN, ...options, headers });

  if (allowRetry && usedBearer && (response.status === 401 || response.status === 403)){
    REJECTED_TOKENS.add(bearer);
    const retryToken = nextBearerToken();
    if (retryToken && retryToken !== bearer){
      return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: true });
    }
    return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: false });
  }

  return response;
}

function buildError(res, text){
  const message = `${res.status}: ${text || res.statusText || 'Request failed'}`;
  const err = new Error(message);
  err.status = res.status;
  err.body = text;
  return err;
}

function isAuthError(err){
  if (!err) return false;
  if (err.status === 401 || err.status === 403) return true;
  const msg = String(err.message || err || '').toLowerCase();
  return msg.includes('401') || msg.includes('403') || msg.includes('unauthor');
}

function redirectToUnauthorized(params = {}){
  try {
    const path = (window.location.pathname || '').toLowerCase();
    if (path.endsWith('/unauthorized') || path.endsWith('/unauthorized.html')) {
      return true;
    }
  } catch (err) {}

  const targetParams = params && typeof params === 'object' ? params : {};
  let href = '/akuvox-ac/unauthorized';
  try {
    href = buildHref('unauthorized', targetParams);
  } catch (err) {}

  let delivered = false;
  try {
    delivered = requestParentNav('unauthorized', targetParams, { replaceState: true });
  } catch (err) {}

  if (!delivered) {
    try { window.location.replace(href); }
    catch (err) { window.location.href = href; }
  }
  return true;
}

function handleAuthError(err){
  if (!isAuthError(err)) return false;
  redirectToUnauthorized();
  return true;
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

async function apiGet(url){
  const r = await fetchWithAuth(url);
  if (!r.ok){
    const text = await r.text();
    const err = buildError(r, text);
    handleAuthError(err);
    throw err;
  }
  return r.json();
}
async function apiPost(url, body){
  const r = await fetchWithAuth(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body||{}) });
  if (!r.ok){
    const text = await r.text();
    const err = buildError(r, text);
    handleAuthError(err);
    throw err;
  }
  return r.json();
}
const UI_ROOT = '/akuvox-ac';
function buildHref(slug, params = {}) {
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === undefined || value === null || value === '') return;
    search.set(key, value);
  });
  const token = sessionStorage.getItem('akuvox_ll_token');
  if (token) search.set('token', token);
  const query = search.toString();
  const clean = String(slug || '').replace(/_/g, '-');
  return `${UI_ROOT}/${clean}${query ? `?${query}` : ''}`;
}
function requestParentNav(view, params = {}, options = {}) {
  try {
    if (window.parent && window.parent !== window) {
      const msg = {
        type: 'akuvox-nav',
        view: String(view || ''),
        slug: String(view || ''),
        params
      };
      if (options.updateHistory === false) msg.updateHistory = false;
      if (options.replaceState) msg.replaceState = true;
      window.parent.postMessage(msg, window.location.origin);
      return true;
    }
  } catch (err) {}
  return false;
}
function openInApp(view, params = {}, options = {}) {
  const href = buildHref(view, params);
  const delivered = requestParentNav(view, params, options);
  if (!delivered) {
    window.location.href = href;
  }
  return delivered;
}

const API_SETTINGS = signedPath('settings', '/api/akuvox_ac/ui/settings');
const API_PHONES   = signedPath('phones', '/api/akuvox_ac/ui/phones');

let SETTINGS_DATA = { integrity_interval_minutes: null, auto_sync_delay_minutes: 30, alerts: { targets: {} }, registry_users: [] };
let PHONES = [];
let USERS = [];
let ALERT_TARGETS = {};
let alertsSaving = false;
let integritySaving = false;
let integritySavedTimer = null;
let autoSyncSaving = false;
let autoSyncSavedTimer = null;

function setBusy(yes){ document.getElementById('busy').style.display = yes ? 'inline-block':'none'; }
function hideIntegritySavedOverlay(){
  const overlay = document.getElementById('integritySavedOverlay');
  if (!overlay) return;
  overlay.classList.remove('visible');
  if (integritySavedTimer){
    clearTimeout(integritySavedTimer);
    integritySavedTimer = null;
  }
}
function showIntegritySavedOverlay(message = 'Saved'){
  const overlay = document.getElementById('integritySavedOverlay');
  if (!overlay) return;
  overlay.textContent = message;
  overlay.classList.add('visible');
  if (integritySavedTimer){
    clearTimeout(integritySavedTimer);
  }
  integritySavedTimer = setTimeout(() => {
    overlay.classList.remove('visible');
    integritySavedTimer = null;
  }, 5000);
}
function hideAutoSyncSavedOverlay(){
  const overlay = document.getElementById('autoSyncSavedOverlay');
  if (!overlay) return;
  overlay.classList.remove('visible');
  if (autoSyncSavedTimer){
    clearTimeout(autoSyncSavedTimer);
    autoSyncSavedTimer = null;
  }
}
function showAutoSyncSavedOverlay(message = 'Saved'){
  const overlay = document.getElementById('autoSyncSavedOverlay');
  if (!overlay) return;
  overlay.textContent = message;
  overlay.classList.add('visible');
  if (autoSyncSavedTimer){
    clearTimeout(autoSyncSavedTimer);
  }
  autoSyncSavedTimer = setTimeout(() => {
    overlay.classList.remove('visible');
    autoSyncSavedTimer = null;
  }, 5000);
}
function setIntegrityStatus(text, tone = 'muted') {
  const el = document.getElementById('integrityStatus');
  if (!el) return;
  if (tone === 'success') {
    el.textContent = '';
    el.className = 'visually-hidden small mt-2';
    showIntegritySavedOverlay(text || 'Saved');
    return;
  }
  hideIntegritySavedOverlay();
  if (!text) {
    el.textContent = '';
    el.className = 'visually-hidden small mt-2';
    return;
  }
  el.textContent = text;
  el.className = 'small mt-2';
  if (tone === 'error') el.classList.add('text-danger');
  else el.classList.add('muted');
}
function setAutoSyncStatus(text, tone = 'muted') {
  const el = document.getElementById('autoSyncStatus');
  if (!el) return;
  if (tone === 'success') {
    el.textContent = '';
    el.className = 'visually-hidden small mt-2';
    showAutoSyncSavedOverlay(text || 'Saved');
    return;
  }
  hideAutoSyncSavedOverlay();
  if (!text) {
    el.textContent = '';
    el.className = 'visually-hidden small mt-2';
    return;
  }
  el.textContent = text;
  el.className = 'small mt-2';
  if (tone === 'error') el.classList.add('text-danger');
  else el.classList.add('muted');
}
function setAlertsStatus(text, tone = 'muted') {
  const el = document.getElementById('alertsStatus');
  if (!el) return;
  if (!text) { el.textContent = ''; el.classList.add('visually-hidden'); return; }
  el.textContent = text;
  el.className = tone === 'error' ? 'text-danger small' : tone === 'success' ? 'text-success small' : 'muted small';
  el.classList.remove('visually-hidden');
}

function autoSyncRange(){
  const minRaw = Number(SETTINGS_DATA?.min_auto_sync_delay_minutes);
  const maxRaw = Number(SETTINGS_DATA?.max_auto_sync_delay_minutes);
  const min = Number.isFinite(minRaw) ? Math.max(1, Math.round(minRaw)) : 5;
  let max = Number.isFinite(maxRaw) ? Math.round(maxRaw) : 60;
  if (max < min) max = min;
  return { min, max };
}

function renderAutoSyncDelay(){
  const input = document.getElementById('autoSyncDelayInput');
  if (!input) return;
  const { min, max } = autoSyncRange();
  let minutes = Number(SETTINGS_DATA.auto_sync_delay_minutes);
  if (!Number.isFinite(minutes)) minutes = 30;
  minutes = Math.round(minutes);
  if (minutes < min) minutes = min;
  if (minutes > max) minutes = max;
  SETTINGS_DATA.auto_sync_delay_minutes = minutes;
  input.min = String(min);
  input.max = String(max);
  input.value = String(minutes);
  setAutoSyncStatus('');
}

function minutesToHHMM(minutes){
  const value = Number(minutes);
  if (!Number.isFinite(value) || value <= 0) return '';
  const hrs = Math.floor(value / 60);
  const mins = value % 60;
  return `${String(hrs).padStart(2,'0')}:${String(mins).padStart(2,'0')}`;
}
function hhmmToMinutes(str){
  if (!str || typeof str !== 'string') return null;
  const clean = str.trim();
  if (!/^\d{1,2}:\d{2}$/.test(clean)) return null;
  const [h, m] = clean.split(':');
  const hours = Number(h);
  const mins = Number(m);
  if (!Number.isInteger(hours) || !Number.isInteger(mins)) return null;
  const total = hours * 60 + mins;
  if (mins >= 60) return null;
  return Math.max(5, Math.min(1440, total));
}

function friendlyName(service){
  const found = PHONES.find(p => p.service === service);
  if (found) return found.name || found.service;
  return service;
}

function ensureTargetDefaults(target){
  if (!ALERT_TARGETS[target] || typeof ALERT_TARGETS[target] !== 'object'){
    ALERT_TARGETS[target] = {
      device_offline: false,
      integrity_failed: false,
      any_denied: false,
      granted: { any: false, users: [] }
    };
  } else {
    const cfg = ALERT_TARGETS[target];
    if (typeof cfg.device_offline !== 'boolean') cfg.device_offline = Boolean(cfg.device_offline);
    if (typeof cfg.integrity_failed !== 'boolean') cfg.integrity_failed = Boolean(cfg.integrity_failed);
    if (typeof cfg.any_denied !== 'boolean') cfg.any_denied = Boolean(cfg.any_denied);
    if (!cfg.granted || typeof cfg.granted !== 'object') cfg.granted = { any: false, users: [] };
    if (typeof cfg.granted.any !== 'boolean') cfg.granted.any = Boolean(cfg.granted.any);
    if (!Array.isArray(cfg.granted.users)) cfg.granted.users = [];
    cfg.granted.users = Array.from(new Set(cfg.granted.users.map(u => String(u))));
  }
}

function renderIntegrity(){
  const input = document.getElementById('integrityInput');
  if (!input) return;
  const minutes = SETTINGS_DATA.integrity_interval_minutes || 15;
  input.value = minutesToHHMM(minutes);
  setIntegrityStatus('');
}

function availablePhonesForSelect(){
  const configured = new Set(Object.keys(ALERT_TARGETS || {}));
  return PHONES.filter(p => !configured.has(p.service));
}

function renderAlerts(){
  const wrap = document.getElementById('alertsContainer');
  if (!wrap) return;
  wrap.innerHTML = '';
  const targets = Object.keys(ALERT_TARGETS || {});

  const addSel = document.getElementById('addTargetSelect');
  if (addSel){
    addSel.innerHTML = '';
    const opts = availablePhonesForSelect();
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = opts.length ? 'Add device…' : '(no additional devices)';
    placeholder.disabled = true;
    placeholder.selected = true;
    addSel.appendChild(placeholder);
    opts.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.service;
      opt.textContent = friendlyName(p.service);
      addSel.appendChild(opt);
    });
    addSel.disabled = opts.length === 0;
  }

  if (!targets.length){
    const empty = document.createElement('div');
    empty.className = 'text-muted';
    empty.textContent = PHONES.length ? 'No alert targets configured yet.' : 'No Home Assistant mobile app notify targets were found.';
    wrap.appendChild(empty);
    return;
  }

  targets.sort((a,b) => friendlyName(a).localeCompare(friendlyName(b))).forEach(service => {
    ensureTargetDefaults(service);
    const cfg = ALERT_TARGETS[service];
    const card = document.createElement('div');
    card.className = 'card mb-3';
    card.innerHTML = `
      <div class="card-header d-flex justify-content-between align-items-center">
        <span><i class="bi bi-phone"></i> ${friendlyName(service)}</span>
        <button class="btn btn-sm btn-outline-danger" data-remove="${service}"><i class="bi bi-x-lg"></i> Remove</button>
      </div>
      <div class="card-body">
        <div class="form-check">
          <input class="form-check-input" type="checkbox" data-target="${service}" data-field="device_offline" ${cfg.device_offline ? 'checked' : ''}>
          <label class="form-check-label">Device Offline (5 minute delay)</label>
        </div>
        <div class="form-check mt-2">
          <input class="form-check-input" type="checkbox" data-target="${service}" data-field="integrity_failed" ${cfg.integrity_failed ? 'checked' : ''}>
          <label class="form-check-label">Device Integrity Check Failed</label>
        </div>
        <div class="form-check mt-2">
          <input class="form-check-input" type="checkbox" data-target="${service}" data-field="any_denied" ${cfg.any_denied ? 'checked' : ''}>
          <label class="form-check-label">Any User Denied Access</label>
        </div>
        <div class="form-check mt-2">
          <input class="form-check-input" type="checkbox" data-target="${service}" data-field="granted_any" ${cfg.granted.any ? 'checked' : ''}>
          <label class="form-check-label">Any User Granted Access</label>
        </div>
        <div class="mt-3">
          <label class="form-label">Specific users to notify on grant</label>
          <select class="form-select" multiple size="5" data-target="${service}" data-field="granted_users"></select>
          <div class="form-text">Hold Ctrl/Cmd to select multiple users.</div>
        </div>
      </div>`;
    const select = card.querySelector('select[data-field="granted_users"]');
    if (select){
      USERS.forEach(user => {
        const opt = document.createElement('option');
        opt.value = user.id;
        opt.textContent = `${user.name} (${user.id})`;
        if (cfg.granted.users.includes(user.id)) opt.selected = true;
        select.appendChild(opt);
      });
    }
    wrap.appendChild(card);
  });

  wrap.querySelectorAll('button[data-remove]').forEach(btn => {
    btn.addEventListener('click', async () => {
      const service = btn.getAttribute('data-remove');
      if (!service) return;
      delete ALERT_TARGETS[service];
      SETTINGS_DATA.alerts = SETTINGS_DATA.alerts || { targets: {} };
      SETTINGS_DATA.alerts.targets = ALERT_TARGETS;
      renderAlerts();
      await saveAlerts();
    });
  });

  wrap.querySelectorAll('input[data-field]').forEach(input => {
    input.addEventListener('change', async () => {
      const service = input.getAttribute('data-target');
      const field = input.getAttribute('data-field');
      if (!service || !field) return;
      ensureTargetDefaults(service);
      const cfg = ALERT_TARGETS[service];
      const checked = input.checked;
      if (field === 'device_offline') cfg.device_offline = checked;
      else if (field === 'integrity_failed') cfg.integrity_failed = checked;
      else if (field === 'any_denied') cfg.any_denied = checked;
      else if (field === 'granted_any') cfg.granted.any = checked;
      SETTINGS_DATA.alerts.targets = ALERT_TARGETS;
      await saveAlerts();
    });
  });

  wrap.querySelectorAll('select[data-field="granted_users"]').forEach(sel => {
    sel.addEventListener('change', async () => {
      const service = sel.getAttribute('data-target');
      if (!service) return;
      ensureTargetDefaults(service);
      const values = Array.from(sel.selectedOptions).map(opt => opt.value);
      ALERT_TARGETS[service].granted.users = values;
      SETTINGS_DATA.alerts.targets = ALERT_TARGETS;
      await saveAlerts();
    });
  });
}

async function saveIntegrity(minutes){
  if (integritySaving) return;
  integritySaving = true;
  try{
    setIntegrityStatus('Saving…');
    const res = await apiPost(API_SETTINGS, { integrity_interval_minutes: minutes });
    if (res.integrity_interval_minutes){
      SETTINGS_DATA.integrity_interval_minutes = res.integrity_interval_minutes;
      setIntegrityStatus('Saved', 'success');
    } else {
      setIntegrityStatus('Saved', 'success');
    }
  }catch(err){
    if (handleAuthError(err)) return;
    setIntegrityStatus('Save failed', 'error');
    alert('Failed to update integrity interval: ' + (err && err.message ? err.message : err));
  }finally{
    integritySaving = false;
  }
}

async function saveAutoSyncDelay(minutes){
  if (autoSyncSaving) return;
  autoSyncSaving = true;
  try{
    setAutoSyncStatus('Saving…');
    const res = await apiPost(API_SETTINGS, { auto_sync_delay_minutes: minutes });
    const returned = Number(res.auto_sync_delay_minutes);
    if (Number.isFinite(returned)){
      const { min, max } = autoSyncRange();
      const normalized = Math.min(max, Math.max(min, Math.round(returned)));
      SETTINGS_DATA.auto_sync_delay_minutes = normalized;
      const input = document.getElementById('autoSyncDelayInput');
      if (input) input.value = String(normalized);
    }
    setAutoSyncStatus('Saved', 'success');
  }catch(err){
    if (handleAuthError(err)) return;
    setAutoSyncStatus('Save failed', 'error');
    alert('Failed to update automatic sync delay: ' + (err && err.message ? err.message : err));
  }finally{
    autoSyncSaving = false;
  }
}

async function saveAlerts(){
  if (alertsSaving) return;
  alertsSaving = true;
  try{
    setAlertsStatus('Saving…');
    const res = await apiPost(API_SETTINGS, { alerts: { targets: ALERT_TARGETS } });
    if (res.alerts && res.alerts.targets){
      ALERT_TARGETS = res.alerts.targets;
      SETTINGS_DATA.alerts.targets = ALERT_TARGETS;
      Object.keys(ALERT_TARGETS).forEach(ensureTargetDefaults);
    }
    setAlertsStatus('Saved ✓', 'success');
  }catch(err){
    if (handleAuthError(err)) return;
    setAlertsStatus('Save failed', 'error');
    alert('Failed to update alerts: ' + (err && err.message ? err.message : err));
  }finally{
    alertsSaving = false;
  }
}

async function loadData(){
  setBusy(true);
  try{
    const [settingsResp, phonesResp] = await Promise.all([
      apiGet(API_SETTINGS),
      apiGet(API_PHONES).catch((err) => {
        handleAuthError(err);
        return { phones: [] };
      })
    ]);
    SETTINGS_DATA = settingsResp || { integrity_interval_minutes: 15, auto_sync_delay_minutes: 30, alerts: { targets: {} }, registry_users: [] };
    const minDelay = Number(settingsResp?.min_auto_sync_delay_minutes);
    const maxDelay = Number(settingsResp?.max_auto_sync_delay_minutes);
    const safeMinDelay = Number.isFinite(minDelay) ? Math.max(1, Math.round(minDelay)) : 5;
    const safeMaxDelay = Number.isFinite(maxDelay) ? Math.max(safeMinDelay, Math.round(maxDelay)) : Math.max(safeMinDelay, 60);
    SETTINGS_DATA.min_auto_sync_delay_minutes = safeMinDelay;
    SETTINGS_DATA.max_auto_sync_delay_minutes = safeMaxDelay;
    const rawDelayValue = SETTINGS_DATA.auto_sync_delay_minutes;
    let delayValue = Number(rawDelayValue);
    if (!Number.isFinite(delayValue) || rawDelayValue === null || rawDelayValue === undefined || rawDelayValue === '') delayValue = 30;
    delayValue = Math.round(delayValue);
    if (delayValue < safeMinDelay) delayValue = safeMinDelay;
    if (delayValue > safeMaxDelay) delayValue = safeMaxDelay;
    SETTINGS_DATA.auto_sync_delay_minutes = delayValue;
    PHONES = Array.isArray(phonesResp.phones) ? phonesResp.phones : [];
    USERS = Array.isArray(SETTINGS_DATA.registry_users) ? SETTINGS_DATA.registry_users : [];
    ALERT_TARGETS = (SETTINGS_DATA.alerts && SETTINGS_DATA.alerts.targets) ? { ...SETTINGS_DATA.alerts.targets } : {};
    Object.keys(ALERT_TARGETS).forEach(ensureTargetDefaults);
    renderAutoSyncDelay();
    renderIntegrity();
    renderAlerts();
  } catch (err){
    if (handleAuthError(err)) return;
    alert('Failed to load settings: ' + (err && err.message ? err.message : err));
  } finally {
    setBusy(false);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('btnBack')?.addEventListener('click', (e) => {
    e.preventDefault();
    openInApp('index', {}, { replaceState: true });
  });

  const autoSyncInput = document.getElementById('autoSyncDelayInput');
  autoSyncInput?.addEventListener('input', () => {
    hideAutoSyncSavedOverlay();
    setAutoSyncStatus('');
  });
  autoSyncInput?.addEventListener('change', async () => {
    const { min, max } = autoSyncRange();
    const rawStr = (autoSyncInput.value ?? '').toString().trim();
    if (!rawStr){
      setAutoSyncStatus(`Enter a number between ${min} and ${max}`, 'error');
      return;
    }
    const raw = Number(rawStr);
    if (!Number.isFinite(raw)){
      setAutoSyncStatus(`Enter a number between ${min} and ${max}`, 'error');
      return;
    }
    const val = Math.round(raw);
    if (val < min || val > max){
      setAutoSyncStatus(`Enter a number between ${min} and ${max}`, 'error');
      return;
    }
    SETTINGS_DATA.auto_sync_delay_minutes = val;
    autoSyncInput.value = String(val);
    await saveAutoSyncDelay(val);
  });

  const integrityInput = document.getElementById('integrityInput');
  integrityInput?.addEventListener('input', hideIntegritySavedOverlay);
  integrityInput?.addEventListener('change', async () => {
    const val = hhmmToMinutes(integrityInput.value);
    if (val === null){
      setIntegrityStatus('Enter a valid HH:MM between 00:05 and 24:00', 'error');
      return;
    }
    SETTINGS_DATA.integrity_interval_minutes = val;
    await saveIntegrity(val);
  });

  document.getElementById('addTargetSelect')?.addEventListener('change', async (ev) => {
    const service = ev.target.value;
    if (!service) return;
    ensureTargetDefaults(service);
    ALERT_TARGETS[service] = ALERT_TARGETS[service];
    SETTINGS_DATA.alerts.targets = ALERT_TARGETS;
    ev.target.value = '';
    renderAlerts();
    await saveAlerts();
  });

  loadData();
});
</script>

<div class="container py-3">
  <div class="d-flex align-items-center gap-2">
    <button class="btn btn-outline-light" id="btnBack"><i class="bi bi-arrow-left"></i> Back</button>
    <h2 class="m-0">Global Settings</h2>
    <span id="busy" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display:none;"></span>
  </div>

  <div class="card mt-3">
    <div class="card-header">Automatic Change Sync Delay</div>
    <div class="card-body">
      <p class="muted">Set how long to wait before automatically syncing user updates to every participating device. Lower values push changes out sooner, while higher values batch multiple edits together. Choose between 5 and 60 minutes.</p>
      <div class="saved-input-wrap">
        <input id="autoSyncDelayInput" class="form-control" type="number" min="5" max="60" step="1" />
        <div id="autoSyncSavedOverlay" class="saved-overlay">Saved</div>
      </div>
      <div id="autoSyncStatus" class="visually-hidden small mt-2"></div>
    </div>
  </div>

  <div class="card mt-3">
    <div class="card-header">Integrity Check Interval</div>
    <div class="card-body">
      <p class="muted">Integrity checks automatically compare each device's data with the server so everything stays accurate and up to date. Choose how often to run them (minimum 5 minutes, maximum 24 hours).</p>
      <div class="saved-input-wrap">
        <input id="integrityInput" class="form-control" placeholder="HH:MM" />
        <div id="integritySavedOverlay" class="saved-overlay">Saved</div>
      </div>
      <div id="integrityStatus" class="visually-hidden small mt-2"></div>
    </div>
  </div>

  <div class="card mt-3">
    <div class="card-header d-flex justify-content-between align-items-center">
      <span>Alert Targets</span>
      <select id="addTargetSelect" class="form-select form-select-sm" style="width:auto;"></select>
    </div>
    <div class="card-body">
      <p class="muted">Choose which Home Assistant mobile app devices receive alerts. Configure per-device notification rules below.</p>
      <div id="alertsContainer"></div>
      <div id="alertsStatus" class="visually-hidden mt-3"></div>
    </div>
  </div>
</div>
</body>
</html>
