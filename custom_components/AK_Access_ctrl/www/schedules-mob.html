<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Access Schedules</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />
  <style>
    :root{ --bg:#0b1320; --card:#111a2b; --border:#1b2942; --text:#e6edf3; --muted:#a5b5cc; }
    body{ background:var(--bg); color:var(--text); }
    .card{ background:#111a2b; border:1px solid #1b2942; }
    .muted{ color:var(--muted); }
    .schedule-window{
      background:#0d1729;
      border:1px solid var(--border);
      border-radius:0.75rem;
      padding:1rem;
      margin-bottom:1rem;
    }
    .schedule-window-days{
      display:flex;
      flex-wrap:wrap;
      gap:0.5rem;
    }
    .schedule-window-days .btn{ min-width:3rem; }
    .schedule-window-empty{
      color:var(--muted);
      font-style:italic;
      font-size:0.9rem;
      display:none;
    }
    .schedule-time-input{ font-family:inherit; }
  </style>
</head>
<body>
<script>
(function captureToken(){
  const qs = new URLSearchParams(location.search);
  const token = qs.get('token');
  if (token) sessionStorage.setItem('akuvox_ll_token', token);
})();

const UI_ROOT = '/akuvox-ac';
const SAME_ORIGIN = { credentials: 'same-origin' };
const REJECTED_TOKENS = new Set();

const AUTH_SIG_KEY = 'akuvox_auth_sig';

function readAuthSigFrom(search = location.search){
  try {
    const params = new URLSearchParams(search);
    const value = params.get('authSig');
    return value || '';
  } catch (err) {
    return '';
  }
}

function rememberAuthSig(value){
  if (!value) return;
  try { sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
  try { window.AK_AC_AUTH_SIG = value; } catch (err) {}
  try {
    if (window.parent && window.parent !== window) {
      const parent = window.parent;
      try { parent.sessionStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.localStorage.setItem(AUTH_SIG_KEY, value); } catch (err) {}
      try { parent.AK_AC_AUTH_SIG = value; } catch (err) {}
    }
  } catch (err) {}
}

function currentAuthSig(){
  const fromUrl = readAuthSigFrom();
  if (fromUrl) {
    rememberAuthSig(fromUrl);
    return fromUrl;
  }

  const sources = [
    () => {
      try { return sessionStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return localStorage.getItem(AUTH_SIG_KEY); } catch (err) { return null; }
    },
    () => {
      try { return window.AK_AC_AUTH_SIG || null; } catch (err) { return null; }
    },
    () => {
      try {
        if (window.parent && window.parent !== window) {
          const parent = window.parent;
          return parent.AK_AC_AUTH_SIG
            || (parent.sessionStorage && parent.sessionStorage.getItem(AUTH_SIG_KEY))
            || (parent.localStorage && parent.localStorage.getItem(AUTH_SIG_KEY));
        }
      } catch (err) {}
      return null;
    }
  ];

  for (const getter of sources) {
    const value = getter();
    if (value) {
      rememberAuthSig(value);
      return value;
    }
  }

  return '';
}

rememberAuthSig(readAuthSigFrom());

function persistTokens(access, refresh) {
  if (!access) return null;
  const payload = { access_token: access };
  if (refresh) payload.refresh_token = refresh;
  try { sessionStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  try { localStorage.setItem('hassTokens', JSON.stringify(payload)); } catch (err) {}
  return access;
}

function extractTokenFromAuth(auth) {
  if (!auth || typeof auth !== 'object') return null;
  const access = auth.accessToken
    || auth.access_token
    || auth?.token?.access_token
    || auth?.data?.access_token
    || null;
  const refresh = auth.refreshToken
    || auth.refresh_token
    || auth?.token?.refresh_token
    || auth?.data?.refresh_token
    || null;
  if (access) {
    return persistTokens(access, refresh);
  }
  return null;
}

function scanTokenStorage(storage) {
  if (!storage) return null;
  try {
    const raw = storage.getItem('hassTokens');
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {
        if (typeof raw === 'string' && raw.trim()) {
          return persistTokens(raw.trim());
        }
      }
    }
    for (const key of Object.keys(storage)) {
      if (!/auth|token|hass/i.test(key)) continue;
      try {
        const parsed = JSON.parse(storage.getItem(key));
        const token = extractTokenFromAuth(parsed);
        if (token) return token;
      } catch (err) {}
    }
  } catch (err) {}
  return null;
}

function tokenFromWindow(win) {
  if (!win) return null;
  let token = null;
  token = scanTokenStorage(win.sessionStorage) || scanTokenStorage(win.localStorage);
  if (token) return token;

  token = extractTokenFromAuth(win.hassAuth)
    || extractTokenFromAuth(win.auth)
    || extractTokenFromAuth(win.AK_AC_HA_AUTH)
    || null;
  if (token) return token;

  try {
    const conn = win.hassConnection;
    if (conn && typeof conn.then === 'function') {
      conn.then((resolved) => {
        try {
          extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
        } catch (err) {}
      }).catch(() => {});
    } else if (conn) {
      token = extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      if (token) return token;
    }
  } catch (err) {}

  return null;
}

function walkAuthWindows(start) {
  const visited = new Set();
  let current = start;
  while (current && !visited.has(current)) {
    const token = tokenFromWindow(current);
    if (token) return token;
    visited.add(current);

    let next = null;
    try {
      next = current.parent;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    try {
      next = current.opener;
    } catch (err) {
      next = null;
    }
    if (next && next !== current && !visited.has(next)) {
      current = next;
      continue;
    }

    break;
  }
  return null;
}

(function bootstrapAuthWatchers() {
  const seen = new WeakSet();
  function attach(win) {
    if (!win || seen.has(win)) return;
    seen.add(win);
    try { extractTokenFromAuth(win.hassAuth || win.auth || win.AK_AC_HA_AUTH); } catch (err) {}
    try {
      const conn = win.hassConnection;
      if (conn && typeof conn.then === 'function') {
        conn.then((resolved) => {
          try {
            extractTokenFromAuth(resolved?.auth || resolved?.options?.auth || resolved);
          } catch (err) {}
        }).catch(() => {});
      } else if (conn) {
        extractTokenFromAuth(conn?.auth || conn?.options?.auth || conn);
      }
    } catch (err) {}
    try {
      if (win.parent && win.parent !== win) attach(win.parent);
    } catch (err) {}
    try {
      if (win.opener) attach(win.opener);
    } catch (err) {}
  }
  attach(window);
})();

function findHaToken(){
  const existing = sessionStorage.getItem('akuvox_ll_token');
  if (existing) return existing;
  const token = walkAuthWindows(window);
  if (token) {
    try { sessionStorage.setItem('akuvox_ll_token', token); } catch (err) {}
  }
  return token;
}

function nextBearerToken(){
  const token = findHaToken();
  if (!token) return null;
  if (REJECTED_TOKENS.has(token)) return null;
  return token;
}

async function fetchWithAuth(url, options = {}, { allowRetry = true } = {}){
  const originalHeaders = { ...(options.headers || {}) };
  let bearer = allowRetry ? nextBearerToken() : null;
  let usedBearer = !!bearer;
  const headers = { ...originalHeaders };
  if (bearer) headers['Authorization'] = 'Bearer ' + bearer;

  const response = await fetch(url, { ...SAME_ORIGIN, ...options, headers });

  if (allowRetry && usedBearer && (response.status === 401 || response.status === 403)){
    REJECTED_TOKENS.add(bearer);
    const retryToken = nextBearerToken();
    if (retryToken && retryToken !== bearer){
      return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: true });
    }
    return fetchWithAuth(url, { ...options, headers: originalHeaders }, { allowRetry: false });
  }

  return response;
}

function buildError(res, text){
  const message = `${res.status}: ${text || res.statusText || 'Request failed'}`;
  const err = new Error(message);
  err.status = res.status;
  err.body = text;
  return err;
}

function isAuthError(err){
  if (!err) return false;
  if (err.status === 401 || err.status === 403) return true;
  const msg = String(err.message || err || '').toLowerCase();
  return msg.includes('401') || msg.includes('403') || msg.includes('unauthor');
}

function buildHref(slug, params = {}){
  const search = new URLSearchParams();
  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === undefined || value === null || value === '') return;
    search.set(key, value);
  });
  const token = findHaToken();
  if (token) search.set('token', token);
  const authSig = currentAuthSig();
  if (authSig) search.set('authSig', authSig);
  const query = search.toString();
  const clean = String(slug || '').replace(/_/g, '-');
  return `${UI_ROOT}/${clean}${query ? `?${query}` : ''}`;
}

function requestParentNav(view, params = {}, options = {}){
  try {
    if (window.parent && window.parent !== window) {
      const msg = { type: 'akuvox-nav', view: String(view || ''), slug: String(view || ''), params };
      if (options.updateHistory === false) msg.updateHistory = false;
      if (options.replaceState) msg.replaceState = true;
      window.parent.postMessage(msg, window.location.origin);
      return true;
    }
  } catch (err) {}
  return false;
}

function redirectToUnauthorized(params = {}){
  try {
    const path = (window.location.pathname || '').toLowerCase();
    if (path.endsWith('/unauthorized') || path.endsWith('/unauthorized.html')) {
      return true;
    }
  } catch (err) {}

  const targetParams = params && typeof params === 'object' ? params : {};
  const href = buildHref('unauthorized', targetParams);
  const delivered = requestParentNav('unauthorized', targetParams, { replaceState: true });
  if (!delivered) {
    try { window.location.replace(href); }
    catch (err) { window.location.href = href; }
  }
  return true;
}

function handleAuthError(err){
  if (!isAuthError(err)) return false;
  redirectToUnauthorized();
  return true;
}

function collectSignedPaths(){
  const result = {};
  const merge = (candidate) => {
    if (!candidate || typeof candidate !== 'object') return;
    for (const [key, value] of Object.entries(candidate)) {
      if (typeof value === 'string' && value) result[key] = value;
    }
  };
  const read = (storage) => {
    if (!storage) return;
    try {
      const raw = storage.getItem('akuvox_signed_paths');
      if (raw) {
        const parsed = JSON.parse(raw);
        merge(parsed);
      }
    } catch (err) {}
  };

  try { merge(window.AK_AC_SIGNED_PATHS); } catch (err) {}
  try { read(typeof sessionStorage !== 'undefined' ? sessionStorage : null); } catch (err) {}
  try { read(typeof localStorage !== 'undefined' ? localStorage : null); } catch (err) {}

  try {
    if (window.parent && window.parent !== window) {
      try { merge(window.parent.AK_AC_SIGNED_PATHS); } catch (err) {}
      try { read(window.parent.sessionStorage); } catch (err) {}
      try { read(window.parent.localStorage); } catch (err) {}
    }
  } catch (err) {}

  return result;
}

const SIGNED_PATHS = collectSignedPaths();

function signedPath(key, fallback){
  if (SIGNED_PATHS && typeof SIGNED_PATHS[key] === 'string' && SIGNED_PATHS[key]) {
    return SIGNED_PATHS[key];
  }
  return fallback;
}

const API_STATE  = signedPath('state', '/api/akuvox_ac/ui/state');
const API_ACTION = signedPath('action', '/api/akuvox_ac/ui/action');

async function getState(){
  const res = await fetchWithAuth(API_STATE);
  if (!res.ok){
    const text = await res.text();
    const err = buildError(res, text);
    handleAuthError(err);
    throw err;
  }
  return res.json();
}

async function action(act, payload){
  const res = await fetchWithAuth(API_ACTION, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action: act, payload })
  });
  if (!res.ok){
    const text = await res.text();
    const err = buildError(res, text);
    handleAuthError(err);
    throw err;
  }
  return res.json();
}

let SCHEDS = {};

const DAY_ORDER = [
  { key: 'mon', label: 'Monday', short: 'Mon' },
  { key: 'tue', label: 'Tuesday', short: 'Tue' },
  { key: 'wed', label: 'Wednesday', short: 'Wed' },
  { key: 'thu', label: 'Thursday', short: 'Thu' },
  { key: 'fri', label: 'Friday', short: 'Fri' },
  { key: 'sat', label: 'Saturday', short: 'Sat' },
  { key: 'sun', label: 'Sunday', short: 'Sun' }
];

const DAY_KEY_LOOKUP = (() => {
  const map = new Map();
  DAY_ORDER.forEach(({ key, label }) => {
    map.set(key, key);
    map.set(label.toLowerCase(), key);
    map.set(label.slice(0, 3).toLowerCase(), key);
  });
  map.set('tues', 'tue');
  map.set('thur', 'thu');
  map.set('thurs', 'thu');
  map.set('weds', 'wed');
  return map;
})();

function truthy(value){
  if (typeof value === 'string'){
    return ['1','true','yes','y','on','enable','enabled'].includes(value.trim().toLowerCase());
  }
  return !!value;
}

function normalizeDayKey(value){
  if (value === null || value === undefined) return null;
  const text = String(value).trim().toLowerCase();
  if (!text) return null;
  if (DAY_KEY_LOOKUP.has(text)) return DAY_KEY_LOOKUP.get(text);
  const short = text.slice(0, 3);
  if (DAY_KEY_LOOKUP.has(short)) return DAY_KEY_LOOKUP.get(short);
  return null;
}

function minutesFromTime(value){
  if (value === null || value === undefined) return null;
  if (typeof value === 'number' && Number.isFinite(value)){
    let mins = Math.floor(value);
    if (mins < 0) mins = 0;
    if (mins > 1439) mins = 1439;
    return mins;
  }
  const text = String(value).trim();
  if (!text) return null;
  const parts = text.split(':');
  if (parts.length >= 2){
    const hh = Number(parts[0]);
    const mm = Number(parts[1]);
    if (Number.isFinite(hh) && Number.isFinite(mm)){
      const clampedH = Math.max(0, Math.min(23, Math.floor(hh)));
      const clampedM = Math.max(0, Math.min(59, Math.floor(mm)));
      return clampedH * 60 + clampedM;
    }
  }
  const digits = text.replace(/[^0-9]/g, '');
  if (digits.length === 3 || digits.length === 4){
    const padded = digits.length === 3 ? `0${digits}` : digits;
    const hh = Number(padded.slice(0, 2));
    const mm = Number(padded.slice(2, 4));
    if (Number.isFinite(hh) && Number.isFinite(mm)){
      const clampedH = Math.max(0, Math.min(23, hh));
      const clampedM = Math.max(0, Math.min(59, mm));
      return clampedH * 60 + clampedM;
    }
  }
  return null;
}

function formatMinutes(minutes){
  const safe = Math.max(0, Math.min(1439, Math.floor(minutes)));
  const hh = String(Math.floor(safe / 60)).padStart(2, '0');
  const mm = String(safe % 60).padStart(2, '0');
  return `${hh}:${mm}`;
}

function blankScheduleSpec(){
  return { start: '', end: '', days: [], always_permit_exit: false, type: '2', date_start: '', date_end: '' };
}

function cloneScheduleSpec(spec){
  const base = blankScheduleSpec();
  if (!spec || typeof spec !== 'object') return base;

  if (spec.type !== undefined) base.type = String(spec.type);
  else if (spec.Type !== undefined) base.type = String(spec.Type);

  if (spec.date_start !== undefined || spec.DateStart !== undefined){
    base.date_start = String(spec.date_start ?? spec.DateStart ?? '').trim();
  }
  if (spec.date_end !== undefined || spec.DateEnd !== undefined){
    base.date_end = String(spec.date_end ?? spec.DateEnd ?? '').trim();
  }

  if ('always_permit_exit' in spec){
    base.always_permit_exit = truthy(spec.always_permit_exit);
  }

  let explicitStart = minutesFromTime(spec.start ?? spec.Start ?? spec.time_start ?? spec.TimeStart);
  let explicitEnd = minutesFromTime(spec.end ?? spec.End ?? spec.time_end ?? spec.TimeEnd);

  let earliest = null;
  let latest = null;

  const selected = new Set();
  const addDay = (value) => {
    const normalized = normalizeDayKey(value);
    if (normalized) selected.add(normalized);
  };

  const rawDays = spec.days;
  if (Array.isArray(rawDays)){
    rawDays.forEach(addDay);
  } else if (rawDays && typeof rawDays === 'object'){
    Object.entries(rawDays).forEach(([key, value]) => {
      if (truthy(value)) addDay(key);
    });
  }

  const boolDayMap = { Mon: 'mon', Tue: 'tue', Wed: 'wed', Thur: 'thu', Fri: 'fri', Sat: 'sat', Sun: 'sun' };
  Object.entries(boolDayMap).forEach(([apiKey, key]) => {
    if (apiKey in spec && truthy(spec[apiKey])) selected.add(key);
  });

  const recordSpan = (start, end, key) => {
    if (start === null || end === null) return;
    selected.add(key);
    earliest = earliest === null ? start : Math.min(earliest, start);
    latest = latest === null ? end : Math.max(latest, end);
  };

  DAY_ORDER.forEach(({ key }) => {
    const spans = Array.isArray(spec[key]) ? spec[key] : [];
    spans.forEach(span => {
      if (!Array.isArray(span) || span.length < 2) return;
      recordSpan(minutesFromTime(span[0]), minutesFromTime(span[1]), key);
    });
  });

  Object.entries(boolDayMap).forEach(([apiKey, key]) => {
    const spans = Array.isArray(spec[apiKey]) ? spec[apiKey] : [];
    spans.forEach(span => {
      if (!Array.isArray(span) || span.length < 2) return;
      recordSpan(minutesFromTime(span[0]), minutesFromTime(span[1]), key);
    });
  });

  if (explicitStart !== null) base.start = formatMinutes(explicitStart);
  else if (earliest !== null) base.start = formatMinutes(earliest);

  if (explicitEnd !== null) base.end = formatMinutes(explicitEnd);
  else if (latest !== null) base.end = formatMinutes(latest);

  base.days = DAY_ORDER.map(({ key }) => key).filter(key => selected.has(key));
  return base;
}

function scheduleExitFlag(spec){
  if (!spec || typeof spec !== 'object') return false;
  if ('always_permit_exit' in spec) return truthy(spec.always_permit_exit);
  return false;
}

function renderDayButtons(selectedDays = [], disabled = false){
  const container = document.getElementById('schedDayButtons');
  if (!container) return;
  container.innerHTML = '';
  const selected = new Set((selectedDays || []).map(day => normalizeDayKey(day)).filter(Boolean));
  DAY_ORDER.forEach(({ key, short }) => {
    const input = document.createElement('input');
    input.type = 'checkbox';
    input.className = 'btn-check';
    input.autocomplete = 'off';
    input.dataset.dayCheck = key;
    input.id = `sched-day-${key}`;
    input.disabled = !!disabled;
    if (selected.has(key)) input.checked = true;
    const label = document.createElement('label');
    label.className = 'btn btn-outline-light btn-sm';
    label.htmlFor = input.id;
    label.textContent = short;
    container.append(input, label);
  });
}

function render(name){
  const spec = name && SCHEDS[name] ? cloneScheduleSpec(SCHEDS[name]) : blankScheduleSpec();
  const isBuiltin = name === '24/7 Access' || name === 'No Access';
  const startInput = document.getElementById('schedStart');
  const endInput = document.getElementById('schedEnd');
  const exitToggle = document.getElementById('schedExit');

  if (startInput){
    startInput.value = spec.start;
    startInput.disabled = isBuiltin;
  }
  if (endInput){
    endInput.value = spec.end;
    endInput.disabled = isBuiltin;
  }
  if (exitToggle){
    exitToggle.checked = scheduleExitFlag(spec);
    exitToggle.disabled = isBuiltin;
  }

  renderDayButtons(spec.days, isBuiltin);
}

function applyAutoColonFormatting(input){
  if (!input || input.dataset.autoColonApplied === '1') return;
  const enforceFormat = () => {
    const digits = String(input.value || '').replace(/[^0-9]/g, '').slice(0, 4);
    if (digits.length <= 2) return;
    const hours = digits.slice(0, 2);
    const minutes = digits.slice(2);
    const formatted = minutes ? `${hours}:${minutes}` : `${hours}:`;
    if (input.value !== formatted) {
      input.value = formatted;
    }
  };
  const handleBlur = () => {
    const parsed = parseTimeValue(input.value);
    if (parsed) {
      input.value = parsed.text;
    }
  };
  input.addEventListener('input', enforceFormat);
  input.addEventListener('blur', handleBlur);
  input.dataset.autoColonApplied = '1';
}

function initTimeInputFormatting(){
  applyAutoColonFormatting(document.getElementById('schedStart'));
  applyAutoColonFormatting(document.getElementById('schedEnd'));
}

function parseTimeValue(value){
  const minutes = minutesFromTime(value);
  if (minutes === null) return null;
  return { minutes, text: formatMinutes(minutes) };
}

async function save(){
  const name = document.getElementById('schedName').value.trim();
  if (!name){ alert('Enter a schedule name'); return; }
  if (name === '24/7 Access' || name === 'No Access'){ alert('Built-in schedules are fixed. Create a custom schedule.'); return; }

  const startInput = document.getElementById('schedStart');
  const endInput = document.getElementById('schedEnd');
  const parsedStart = parseTimeValue(startInput ? startInput.value : '');
  const parsedEnd = parseTimeValue(endInput ? endInput.value : '');
  if (!parsedStart){ alert('Enter a start time in HH:MM.'); return; }
  if (!parsedEnd){ alert('Enter an end time in HH:MM.'); return; }

  const days = [];
  document.querySelectorAll('#schedDayButtons input[data-day-check]').forEach(input => {
    if (input.checked){
      const day = input.getAttribute('data-day-check');
      if (day) days.push(day);
    }
  });
  if (!days.length){ alert('Select at least one day.'); return; }

  const existing = SCHEDS[name] || {};
  const spec = cloneScheduleSpec(existing);
  spec.start = parsedStart.text;
  spec.end = parsedEnd.text;
  spec.days = days;
  const exitToggle = document.getElementById('schedExit');
  spec.always_permit_exit = !!(exitToggle && exitToggle.checked);
  if (!spec.type) spec.type = '2';
  if (spec.date_start === undefined || spec.date_start === null) spec.date_start = '';
  if (spec.date_end === undefined || spec.date_end === null) spec.date_end = '';

  try {
    await action('upsert_schedule', { name, spec });
    location.reload();
  } catch (err) {
    if (handleAuthError(err)) return;
    alert('Failed to save schedule: ' + (err && err.message ? err.message : err));
  }
}

async function del(){
  const name = document.getElementById('schedName').value.trim();
  if (!name) return;
  if (name === '24/7 Access' || name === 'No Access'){ alert('Built-in schedules cannot be deleted.'); return; }
  try {
    await action('delete_schedule', { name });
    location.reload();
  } catch (err) {
    if (handleAuthError(err)) return;
    alert('Failed to delete schedule: ' + (err && err.message ? err.message : err));
  }
}

async function load(){
  try {
    const st = await getState();
    SCHEDS = st.schedules || {};
    const sel = document.getElementById('schedSel');
    const names = Object.keys(SCHEDS);
    sel.innerHTML = names.map(n => `<option>${n}</option>`).join('');
    sel.addEventListener('change', (e) => {
      document.getElementById('schedName').value = e.target.value;
      render(e.target.value);
    });
    if (names.length){
      sel.value = names[0];
      document.getElementById('schedName').value = sel.value;
      render(sel.value);
    } else {
      document.getElementById('schedName').value = '';
      render('');
    }
  } catch (err) {
    if (handleAuthError(err)) return;
    alert('Failed to load schedules: ' + (err && err.message ? err.message : err));
  }
}
</script>
<div class="container py-3">
  <h2>Access Schedules</h2>
  <div class="card p-3">
    <div class="mb-2">
      <label class="form-label">Existing schedules</label>
      <select id="schedSel" class="form-select form-select-sm"></select>
    </div>
    <div class="mb-2"><label class="form-label">Schedule name</label><input id="schedName" class="form-control"/></div>
    <div class="form-check form-switch mb-3">
      <input class="form-check-input" type="checkbox" id="schedExit">
      <label class="form-check-label" for="schedExit">Always permit exit devices</label>
      <div class="form-text">Exit devices treat this schedule as 24/7 when enabled.</div>
    </div>
    <div class="schedule-window" id="scheduleEditor">
      <div class="row g-2 align-items-end">
        <div class="col-12 col-md-4 col-lg-3">
          <label class="form-label small text-uppercase muted" for="schedStart">Start time</label>
          <input id="schedStart" class="form-control form-control-sm schedule-time-input" placeholder="HH:MM" />
        </div>
        <div class="col-12 col-md-4 col-lg-3">
          <label class="form-label small text-uppercase muted" for="schedEnd">End time</label>
          <input id="schedEnd" class="form-control form-control-sm schedule-time-input" placeholder="HH:MM" />
        </div>
      </div>
      <div class="mt-3">
        <div class="muted small mb-1">Applies on days</div>
        <div class="schedule-window-days" id="schedDayButtons"></div>
      </div>
    </div>
    <div class="mt-3 d-flex gap-2">
      <button class="btn btn-success" onclick="save()">Save</button>
      <button class="btn btn-danger" onclick="del()">Delete</button>
      <a class="btn btn-secondary" id="backBtn" href="#">Back</a>
    </div>
  </div>
</div>
<script>
initTimeInputFormatting();
load();
(function initBackButton(){
  try {
    const back = document.getElementById('backBtn');
    if (!back) return;
    const href = buildHref('index');
    back.setAttribute('href', href);
    back.addEventListener('click', (ev) => {
      const delivered = requestParentNav('index', {}, { replaceState: false });
      if (delivered) {
        ev.preventDefault();
      }
    });
  } catch (err) {}
})();
</script>
</body>
</html>
